<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础课程03]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F14%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B03%2F</url>
    <content type="text"><![CDATA[我们已经学习了数十个常用的Linux系统命令，以后要把这些命令通过语法结合使用。这里学习Linux命令与文件读写操作有关的重定向技术的五种模式——标准覆盖输出重定向、标准追加输出重定向、错误覆盖输出重定向、错误追加输出重定向、输入重定向。 输入输出重定向简单用一句话来概括即 “使用输入重定向能够把文件导入到命令中，而输出重定向则是能够把原本要输出到屏幕的数据信息写入到指定文件中”。平常输出重定向会使用得多一些，细分之下又有 标准输出重定向 和 错误输出重定向 两种技术以及 清空写入 和 追加写入 两种模式。 标准输入(STDIN，文件描述符为0)：默认从键盘输入，为0时表示是从其他文件或命令的输入。 标准输出(STDOUT，文件描述符为1)：默认输出到屏幕，为1时表示是文件。 错误输出(STDERR，文件描述符为2)：默认输出到屏幕，为2时表示是文件。 对于输入重定向有这些情况： 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见“分界符”才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 对于输出重定向有这些情况： 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt; &amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 试一下吧，通过标准输出重定向将“man bash”命令原本要输出到屏幕的信息写入到文件中去，效果类似于： 有没有感觉到特别方便呢？那么接下来试试输出重定向技术中的 清空写入 与 追加写入 两种不同模式带来的变化吧~先通过清空模式向文件写入一行数据（该文件中包含上一个实验的man命令信息），然后再通过追加模式向文件再写入一次数据，最终咱们看到的文件内容会是这个样子的：[caijy@localhost Desktop]$ echo &quot;Welcome to linux&quot; &gt; readme.txt[caijy@localhost Desktop]$ echo &quot;Quality linux learning materials&quot; &gt;&gt; readme.txt[caijy@localhost Desktop]$ cat readme.txtWelcome to linuxQuality linux learning materials 虽然都是输出重定向技术，但对于不同命令的标准输出和错误输出还都有点区别，例如查看下当前目录中某个文件的信息吧。因为这个文件是真实存在的，因此使用标准输出即可将数据写入到文件中，而错误的输出重定向则不行，依然会把信息输出到了屏幕上。[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l readme.txt &gt; out.txt[caijy@localhost Desktop]$ cat out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt[caijy@localhost Desktop]$ ls -l readme.txt 2&gt; out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt 那如果是想把命令的报错信息写入到文件呢？例如当您在执行一个自动化的Shell脚本时会特别的实用，因为可以通过把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来学习实践中咱们就以一个不存在的文件做演示吧：[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l xxxls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx &gt; out.txtls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx 2&gt; out.txt[caijy@localhost Desktop]$ cat out.txtls: cannot access xxx: No such file or directory 输入重定向作用是把文件直接导入到命令中。接下来使用输入重定向把文件导入给“wc -l”命令来统计下内容行数吧，这样命令其实等同于接下来要学习的“cat readme.txt | wc-l”的管道符命令组合。[caijy@localhost Desktop]$ wc -l &lt; readme.txt2 管道命令符管道符的输入方法是同时按下键盘的“Shift”与“\”键，执行格式为“命令A | 命令B”，其实管道命令符的作用也能用一句话来概括： “把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入” 。回想前面学习过的grep文本搜索命令通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户，其实只要学完了这个小节，完全可以把下面的两条命令合并到一起。[caijy@localhost Desktop]$ grep &quot;/sbin/nologin&quot; /etc/passwd | wc -l33 学习到了这个管道符就像拿到了一个法宝，让咱们来套用到其他不同的命令上吧，比如用翻页的形式查看/etc目录中的文件列表及属性信息吧（默认会一股脑的都显示到屏幕上，根本看不清楚）： [root@localhost Desktop]# echo &quot;linux&quot; | passwd --stdin rootChanging password for user root.passwd: all authentication tokens updated successfully. 对于这个管道符命令是不是觉得有些相见恨晚？其实玩法还有很多，比如默认发送邮件需要交互式的进行才行，而此时则可以通过一条结合了管道符的命令语句把编辑好的内容与标题一起的“打包”，最终用一条命令就顺利的给用户发送了邮件。[root@localhost Desktop]# echo &quot;Context&quot; | mail -s &quot;Subject&quot; caijy[root@localhost Desktop]# su caijy[caijy@localhost Desktop]$ mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/caijy&quot;: 1 message 1 new&gt;N 1 root Thu Sep 14 11:01 18/612 &quot;Subject&quot; 能不能让这样方便的命令写的更高级一些呢？下面这条自造命令就是通过把mail邮件命令与输入重定向的分界符来结合使用，效果是让用户可以一直的输入内容，直到系统遇到匹配上了用户定义的分界符才最终结束。[root@localhost Desktop]# mail -s &quot;Readme&quot; root@localhost.localdomain &lt;&lt; over&gt; I think linux is very practical&gt; I hope to learn more&gt; can you teach me ?&gt; over 当然大家可不要误解管道命令符只能用一次哦，完全可以这样用：“命令A|命令B|命令C”。 命令行的通配符例如想批量查看所有硬盘文件的相关权限属性，笨笨的命令会是这样的：[root@localhost Desktop]# ls -l /dev/sdabrw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sda[root@localhost Desktop]# ls -l /dev/sda1brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1[root@localhost Desktop]# ls -l /dev/sda2brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda3ls: cannot access /dev/sda3: No such file or directory幸亏我的硬盘文件和分区只有3个，要是有几百个的话，估计一天的工作时间都要忙活这个事了。咱们此时已经能看出一些简单规律了，比如这些硬盘设备文件共性都是以sda开头并且存放到了/dev目录中，那即便不知道分区编号和具体分区的个数也一样可以用通配符来搞定。通配符顾名思义就是通用的匹配信息的符号，比如星号(*)就是代表匹配零个或多个字符，问号(?)是代表匹配单个字符，中括号内加上数字[0-9]代表匹配单个阿拉伯数字的字符，而中括号内加上字母[abc]则是代表匹配单个指定的英文字母。[root@localhost Desktop]# ls -l /dev/sda*brw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sdabrw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2如果只需要看sda后面一定要有个字符的文件相关信息呢？那就要用到问号来通配了。[root@localhost Desktop]# ls -l /dev/sda?brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2您除了可以用[0-9]来通配所有的单个阿拉伯数字，也可以用[135]这样的方式仅匹配这三个指定数字，若没有通配到即不会显示出来：[root@localhost Desktop]# ls -l /dev/sda[0-9]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda[135]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1 常用的转义字符Shell解释器为了能够更好的理解您想表达的意思，还提供了特别丰富的转义符号来帮助程序员处理输入的特殊数据。常见的转义字符包括有：反斜杠()的作用就是转义后面的一个变量变为单纯的字符串，单引号(‘’)则是转义其中所有的变量为单纯的字符串，而双引号（””）是保留其中的变量属性不转义，反引号(``)则是把其中的命令执行后返回一个结果。例如咱们先定义一个名称为PRICE的变量并赋值为5，然后通过双引号括起来输出字符串与变量结合的结果：[root@localhost Desktop]# PRICE=5[root@localhost Desktop]# echo &quot;Price is $PRICE&quot;Price is 5[root@localhost Desktop]# echo &quot;Price is $$PRICE&quot;Price is 44837PRICE原本刚刚是希望能够进一步输出“Price is $5”即价格是五美元的字符串信息，但碰巧美元符号与变量提取符号冲突了，因此输出的并不是预想的信息。需要用转义符把第一个$符号转换成单纯的字符串，再或者把整段都转义成单纯的字符串吧（当然这个只是让您看下效果，并不符合实验需要）：[root@localhost Desktop]# echo &quot;Price is \$$PRICE&quot;Price is $5[root@localhost Desktop]# echo &#39;Price is \$$PRICE&#39;Price is \$$PRICE 最后一个您可能看到结果时会觉得很无用，因此暂且先不用管具体的使用场景，就当作是提前为SHELL编程知识学习做一点小小的铺垫吧。如果只需要某个命令的返回输出值时，就可以用像 命令 这样用反引号括起来的命令格式来达到效果，例如通过反引号与uname -a命令结合通过返回值来查看下本机版本和内核信息吧：[root@localhost Desktop]# echo `uname -a` Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux 重要的环境变量变量是计算机系统中用于保存可变值的数据类型，在Linux系统中一般变量名称都是大写的，这仅算是一种约定俗成的规范，平时可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来指定系统运行环境的一些参数，比如每个用户不同的家目录、邮件保存存放位置等等。 前面小节中提到的一个概念——即Linux系统中一切都是文件，因此Linux命令肯定也不例外，那当用户执行了一条命令之后到底发生了什么事情呢？简单来说就是四个步骤： 第1步骤阶段是判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。 第2步骤阶段是检查用户输入的命令是否为“别名命令”，即用一个自创的命令名称来替换原本的命令名称。可以用alias命令来创建一个属于自己的命令别名，格式为: alias 新的命令=’原命令 -选项/参数’，若要取消一个别名的话则是用unalias命令，格式为：“unalias 别名”。例如以前每次用rm命令删除文件的时候都要被要求再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，咱们可以把它取消掉：[root@localhost Desktop]# alias rmalias rm=&#39;rm -i&#39;[root@localhost Desktop]# unalias rm[root@localhost Desktop]# rm out.txt 第3步骤阶段就是由Bash解释器来判断用户输入的是个内部命令还是个外部命令，内部命令是解释器内部的指令，会被直接的执行，而绝大部分的时候都会是外部命令，交由给第4步骤来继续处理，您可以使用“type 命令名称”来手工判断是内部命令还是外部命令，也是很有趣的。 第4步骤阶段是系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫做PATH，可以简单把它理解成是“解释器的小助手”，作用是告诉Bash解释器要执行的命令可能存放到了那里，然后Bash解释器就会乖乖的在这些目录中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，咱们对PATH变量内这些路径的增加和删除操作将会直接影响bash解释器搜索linux命令的位置。[root@localhost Desktop]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin[root@localhost Desktop]# echo PATH=$PATH:/root/binPATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin:/root/bin 这里有比较经典的问题：“为什么不能在$PATH中添加进当前目录(.)?”答案：虽然把$PATH变量添加了当前目录(.)会在一些情况让用户免去输入命令所在路径的麻烦，但如果黑客在比较常用的公共目录/tmp中存放了一个名为”ls”或”cd”的同名木马文件，那么用户就极有可能错误的执行了。作为一名态度谨慎、有经验的运维人员在接手了一台Linux系统后一定会在执行命令前先检查下PATH变量中是否有可疑的目录，另外读者们从PATH变量的例子中是不是也感觉到环境变量特别实用呢~您可以使用env命令来查看到linux系统中所有的环境变量，在此摘录最重要的10个环境变量： 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的SHELL解释器名称。 HISTSIZE 定义了 history 命令输出的记录数 HISTFILESIZE 定义了在文件 ~/.bash_history 中保存命令的记录总数 MAIL 邮件信箱文件保存路径。 LANG 系统语言、语系名称。 RANDOM 生成一个随机数字。 PS1 bash解释器的提示符。 PATH 定义解释器搜索用户执行命令的路径。 EDITOR 用户默认的文本编辑器。 Linux系统为了能够为每个用户提供独立的、合适的工作运行环境，因此在不同的用户身份下提取一个相同的变量也可能会获得不同的值，例如查看下HOME变量在不同用户身份下的值都有那些吧（su是用于切换用户身份的命令）：[root@localhost Desktop]# echo $HOME/root[root@localhost Desktop]# su - caijyLast login: Thu Sep 14 11:01:16 CST 2017 on pts/0[caijy@localhost ~]$ echo $HOME/home/caijy 其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，如果工作需要完全可以自己手工创建的，例如设置一个名称为WORKDIR的变量，方便用户更轻松的进入一个很深层的目录：[caijy@localhost Desktop]$ mkdir -p c/workdir[caijy@localhost Desktop]$ WORKDIR=c/workdir[caijy@localhost Desktop]$ cd $WORKDIR[caijy@localhost workdir]$ pwd/home/caijy/Desktop/c/workdir 但是这样的变量不具有全局性，作用范围也是有限的，默认不能够被其他用户使用的，如果工作需要的话咱们可以使用export命令将其提升为全局变量，这样其他的用户也就可以使用到这个变量了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程02]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B02%2F</url>
    <content type="text"><![CDATA[新手必须掌握的Linux命令 shell简介通常计算机硬件是由运算器、控制器、存储器、输入/输出设备等等这些物理设备共同组成的，而能够让机箱内各种硬件设备各司其职的东西就叫做系统内核。Linux系统的内核负责驱动硬件、管理活动和分配/管理硬件资源等等任务，如此说来系统内核对计算机正常稳定的运行来讲可真的是太重要了，因此一般不建议直接去编辑内核中的参数，而是让用户通过基于“系统调用接口”开发出的程序/服务来管理计算机，这样一层层环环相扣来满足咱们的日常工作需要.“Shell”——也可称为“壳”，充当的是人与内核（硬件）的翻译官，用户把一些命令“告诉”Shell终端，它就会调用相应的程序服务执行工作啦主流Linux系统选择Bash解释器作为命令行终端主要有以下4项优势: 通过上下方向键来调取过往执行过的Linux命令。 命令或参数仅需输入前几位就可以用tab键补全。 强大的批处理脚本。 实用的环境变量。 man–帮助命令常见执行Linux命令的格式是这样的(中间有空格)： 命令名称 [命令参数] [命令对象] 命令对象一般是指要被处理的文件、目录、用户等资源，而命令参数可以选用长格式（完整的选项名称）也可选用短格式（单个字母的缩写），一般分别用”–”与”-“做前缀。 长格式如:man –help短格式如:man -h 进入Linux，打开terminal,输入：man man,便可看到man命令自身的帮助信息： 进入man命令帮助信息界面后的常用操作按键包括有（与后面章节中学习的vim编辑器非常相像）: 按键 用处 空格键 向下翻一页 Page Down 向下翻一页 Page Up 向上翻一页 HOME 去往首页 END 去往尾页 /关键词 从上至下搜索“关键词” ？关键词 从下至上搜索“关键词” n 定位到下一个关键词 N 定位到上一个关键词 q 退出帮助文档 一般帮助文档都很长，我们应该了解它们的结构来更好得获得帮助 结构名称 代表意义 NAME 命令的名称 SYNOPSIS 参数的大致用法 DESCRIPTION 介绍说明 EXAMPLES 举例说明 OVERVIEW 概述 DEFAULTS 默认的功能 OPTIONS 可用的选项 ENVIRONMENT 环境变量 FILES 用到的文件 SEE ALSO 相关的资料 HISTORY 维护历史 常用系统工作命令echo命令用于在终端显示字符串或输出变量提取后的值，格式为：“echo [字符串 | $变量]”。把指定字符串输出到终端屏幕：使用$变量的方式提取变量值并输出到屏幕： date命令用于显示及设置系统的时间或日期，格式为：”date [选项] [+指定的格式]”。date命令参数常见的格式如下： 参数 作用 %t 跳格（tab键） %H 小时（00-23） %I 小时（00-12） %M 分钟（00-59） %S 秒（00-59） %p 显示本地AM或PM %X 相当于%I:%M:%S %p %Z 显示时区 %A 星期几 (Sunday-Saturday) %a 星期几 (Sun-Sat) %B 完整月份 (January-December) %b 缩写月份 (Jan-Dec) %d 日(01-31) %j 一年中的第几天(001-366) %m 月份(01-12) %Y 完整的年份 按照默认的格式查看当前的系统时间：[caijy@localhost Desktop]$ dateTue Sep 12 20:33:37 CST 2017按照”年-月-日 小时:分钟:秒”的格式查看当前的系统时间：[caijy@localhost Desktop]$ date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-09-12 20:35:30设置当前的系统时间为2017年9月12日21点00分：[caijy@localhost Desktop]$ sudo date -s &quot;20170912 21:00:00&quot;Tue Sep 12 21:00:00 CST 2017再次查看系统时间[caijy@localhost Desktop]$ dateTue Sep 12 21:01:04 CST 2017查看今天是一年中的第几天，其实用这个参数也能够很好的区分备份时间的新旧，即数字越大，越靠近当前时间：[caijy@localhost Desktop]$ date &quot;+%j&quot;255 reboot命令用于重启系统，格式为：”reboot”。重启计算机这种操作会涉及到对硬件资源的管理权限，因此默认只能使用root用户来重启您的电脑：[caijy@localhost Desktop]$ reboot poweroff命令用于关闭系统，格式为：”poweroff”。关机命令也同理，默认只有root管理员用户才可以关闭您的电脑：[caijy@localhost Desktop]$ poweroff wget命令用于在终端中下载网络文件，格式为：“wget [参数] 下载地址”。 参数 说明 -b 后台下载模式 -O 下载到指定mul -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源,包括图片、视频等。 -r 递归下载 ps命令用于查看系统中的进程状态，格式为：“ps [参数]”，常见的ps命令参数有 参数 作用 -a 显示所有的进程（包括其他用户的） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux系统中时刻运行着许许多多的进程，如果能够合理的管理它们，绝对有益于对系统的性能优化，Linux系统中进程最常见的5种不同的状态是运行、中断、不可中断、僵死与停止，它们的含义分别是： R(运行):正在运行或在运行队列中等待。 S(中断):休眠中, 在等待某个条件的形成或接收到信号。 D(不可中断):收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。 Z:(僵死):进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。 T:(停止):进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行。 top命令用于动态的监视进程活动与系统负载等信息，格式为：“top”。这个top命令可真的是太厉害了，它能够动态的查看系统运维状态，完全可以比喻成是“强化版的Windows任务管理器”， top命令前面的五行为系统整体的统计信息： 第1行:系统时间，运行时间，登录终端数，系统负载（分别为1分钟、5分钟、15分钟的平均值，数值越小意味着负载越低）。 第2行:进程总数，运行中的，睡眠中的，停止的，僵死的。 第3行:用户占用资源，系统内核占用资源，改变过优先级的进程，空闲的资源，等待输入输出的时间。此行数据均为CPU数据并以百分比格式显示，例如”99.2 id”意味着有99.2%的CPU处理器资源正在空闲中。 第4行:物理内存总量，使用量，空闲量，作为内核缓存的内存量。 第5行:虚拟内存总量，使用量，空闲量，已被提前加载的内存数据。 pidof命令用于查询某个指定服务进程的PID号码值，格式为：“pidof [参数] [服务名称]”。PID值是区别每个进程的唯一号码，每次在计算机上运行相同的服务程序都很少会获得同样值的PID号码，例如查询下本机sshd服务程序的PID进程号码值：[caijy@localhost Desktop]$ pidof sshd1736 kill命令用于终止某个指定PID号码的服务进程，格式为：“kill [参数] [进程PID号]”。咱们来动手把上面pidof命令查询到的PID号码给终止掉吧，这样操作的效果等同于把sshd服务强制停止。[caijy@localhost Desktop]$ sudo kill 1736killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。(目前尚未安装网卡，找个例子)[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 平时在系统终端中执行一个命令后如果想立即的停止它，您可以同时按下系统组合键“Ctrl+c”，这样命令的进程将会立即被终止，是生产工作中比较常用的命令行快捷键之一。或者有些命令在执行时会不断的在屏幕上输出信息，影响到咱们继续输入命令了，便可以在执行命令时在命令最后面添加上一个“&amp;”符号，这样命令从开始执行就默认被放到系统后台了。 常用系统工作命令为了更好的了解Linux服务器，成为一名合格的运维人员，您必须具备快速查看Linux系统运行状态的能力，因此接下来咱们会逐个来学习下对于网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断命令的使用方法，都是超级实用的Linux命令哦~ ifconfig用于获取网卡配置与网络状态等信息:格式为”ifconfig [网络设备] [参数]”。查看本机当前的网卡配置与网络状态等信息，主要就是看每段开头的网卡名称、inet参数后面的IP地址、ether参数后面的MAC网卡物理地址以及RX、TX的接收与发送数据包的流量大小。 uname命令用于查看系统内核与系统版本等信息，格式为：“uname [-a]”。一般会固定搭配上-a参数来完整查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息:[caijy@localhost Desktop]$ uname -aLinux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux顺便说下，如果您想查看当前系统版本的详细信息需要看redhat-release文件：[caijy@localhost Desktop]$ cat /etc/redhat-releaseRed Hat Enterprise Linux Server release 7.0 (Maipo) uptime命令用于查看系统的负载信息，格式为：“uptime”。这个命令可以为您显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息数据。平均负载值指的是最近1分钟、5分钟、15分钟的系统压力情况（下面加粗的信息部分），负载值越低越好[caijy@localhost Desktop]$ uptime21:14:39 up 31 min, 2 users, load average: 0.20, 0.19, 0.14 free命令用于显示当前系统中内存的使用量信息，格式为：“free [-h]”。为了保证Linux系统不会因硬件故障而突然卡住宕机，那么内存使用量当之无愧是运维人员最应该时刻要关注的数据对象啦，可以使用-h参数来以更人性化的样输出当前内存的实时使用量信息 who命令用于查看当前登入主机的用户终端信息，格式为：”who [参数]”。简单三个字母就可以快捷的显示出所有正在登录着本机的用户名称以及他们正在开启的终端信息： last命令用于查看所有系统的登入记录，格式为：”last [参数]”。使用last命令可以看到本机的登录记录，但由于这些信息都是被以日志文件的形式保存在系统中的数据内容，骇客们很轻易的便可对内容进行篡改，所以千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！ history命令用于显示历史执行过的命令，格式为：“history [-c]”。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录，觉得1000不够用的话还可以修改/etc/profile文件的HISTSIZE变量值，或者使用-c参数来清空里面的历史数据，还可以使用“!编码数字”的方式来重复执行某一次的命令，有很多种有趣的玩法： 历史命令会被保存到用户家目录中的”.bash_history”文件中。Linux系统中以点(.)开头的文件均代表隐藏文件，一般大多会是系统服务文件。[caijy@localhost Desktop]$ cat ~/.bash_history清空该用户在本机中执行的Linux命令历史记录信息：[caijy@localhost Desktop]$ history -c sosreport命令用于收集系统配置并诊断信息后输出结论文档，格式为：“sosreport”。。。有待学习 工作目录切换命令pwd命令用于显示当前所处的工作目录，格式为：“pwd [选项]”。[caijy@localhost Desktop]$ pwd/home/caijy/Desktop cd命令用于切换工作路径，格式为：“cd [目录名称]”。这个命令应该是最最常用的Linux命令之一了，您可以通过cd命令来便捷的切换到不同的工作目录。除了常见的切换目录的方式，还可以使用“cd -”命令来返回到上一次所处的目录或使用“cd ~”命令来切换到当前用户的家目录，亦或使用“cd ~username”则可以切换到其他用户的家目录了~例如使用“cd 路径”的方式切换进/etc目录中：[caijy@localhost Desktop]$ cd /etc同样的道理，再尝试切换进/bin目录中：[caijy@localhost etc]$ cd /bin此时返回到上一次的目录（即/etc目录）：[caijy@localhost bin]$ cd -/etc还可以快速的切换到用户自己的家目录呢：[caijy@localhost etc]$ cd ~[caijy@localhost ~]$ ls命令用于显示目录中的文件信息，格式为：“ls [选项] [文件] ”。当咱们处在不同的工作目录下时，能够看到当前目录下的文件也在发生变化，ls命令的“-a”参数看到全部文件（包括隐藏文件），再结合“-l”参数来查看文件的属性、大小等详细信息。整合之后的命令即可实现查看当前目录中所有文件列表并输出这些文件的属性信息：需要看目录属性信息的话，需要额外添加一个-d参数才可以，例如查看/etc目录的权限与属性信息：[caijy@localhost ~]$ ls -ld /etcdrwxr-xr-x. 132 root root 8192 Sep 12 20:48 /etc 文本文件编辑命令在Linux系统中一切都是文件，而对于服务程序的配置自然也就是在编辑程序的配置文件，如果不能熟练的查阅数据，那以后工作时可就真的要尴尬了。接下来学习几条用于查看文本文件内容的命令吧cat命令用于查看纯文本文件（较短的），格式为：“cat [选项] [文件]”。Linux系统中有需要用于查看文本内容的命令，但其中每个命令又都有自己的特色特点，比如这个cat命令就是用于查看比较精简的文本内容的。这个其实是最好记的命令之一，因为cat在英语中是猫的意思，小猫咪是不是总给您一种娇小、可爱的感觉呢？另外如果您想看文本内容时还顺便显示行号的话，不妨再追加一个“-n”参数试试吧：more命令用于查看纯文本文件（较长的），格式为：“more [选项] 文件”。对于长篇的文本内容，推荐使用more命令来查看文本内容，不仅可以提示您已经阅读了百分之多少，还可以使用空格或回车键向下翻页：head命令用于查看纯文本文档的前N行，格式为：“head [选项] [文件]”。tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为：“tail [选项] [文件]”。当然咱们还会遇到一种更奇葩的情况，比如需要去查看文本内容的最后20行，那么操作方法其实跟head命令是非常相似的，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。而tail命令最强悍的功能是用于持续刷新一个文件的内容，尤其是对于想要实时看到最新日志文件的时候特别有用：tr命令用于替换文本文件中的字符，格式为:“tr [原始字符] [目标字符]”。例如试试把某个文本内容完整替换成大写英文吧：[caijy@localhost Desktop]$ cat 2.txtabcdefghijklmnopqrstuvwxyz[caijy@localhost Desktop]$ cat 2.txt | tr [a-z] [A-Z]ABCDEFGHIJKLMNOPQRSTUVWXYZ wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 例如可以使用“-l”参数来统计行数，而passwd是用于保存系统帐户信息的文件，因此下面的命令就是用于统计当前系统中有多少个用户的作用啦：[caijy@localhost Desktop]$ wc -l /etc/passwd38 /etc/passwd stat命令用于查看文件的具体存储信息和时间等信息，格式“stat 文件名称”。 cut命令用于按“列”来提取文本字符，格式为：“cut [参数] 文本”。如何准确的提取出最想要的数据，这也应该是咱们学习研究的方向之一，按基于“行”的方式来提取是比较简单的，只需要设置好要搜索的关键词即可，但是按列搜索的话不仅要使用“-f”参数来设置需要看的列数，还必须使用“-d”参数来设置间隔符号。因为passwd是用于保存用户信息数据的文件且每一项值都是通过冒号来间隔的，因此可以来尝试下提取出passwd文件中的用户名信息吧，即提取以:（冒号）为间隔符号的第一列内容：[caijy@localhost Desktop]$ head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[caijy@localhost Desktop]$ cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodydbuspolkitdunboundcolordusbmuxdavahiavahi-autoipdlibstoragemgmtsaslauthqemurpcrpcusernfsnobodyrtkitradvdntpchronyabrtpulsegdmgnome-initial-setuppostfixsshdtcpdumpcaijy diff命令用于比较多个文本文件的差异，格式为：”diff [参数] 文件”。仅仅显示比较后的结果，判断文件是否相同：diff --brief diff_A.txt diff_B.txt使用详细的上下文输出格式来描述文件内容具体的不同：diff -c diff_A.txt diff_B.txt 文件目录管理命令touch命令用于创建空白文件与设置文件的各种时间，格式为：“touch [选项] [文件]”。touch命令能够创建出空白的文本文件，但这实在太简单不需要去讲，例如“touch linuxprobe”这样就可以创建出一个空白的名为linuxprobe的文本文件，而有难度的操作主要是用于设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）。 参数 作用 -a 仅修改访问时间“atime” -m 仅修改更改时间“mtime” -d 同时修改atime与mtime [caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16314 Sep 12 21:42 1.txt[caijy@localhost Desktop]$ echo &quot;hello,linux&quot; &gt;&gt; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Sep 13 19:46 1.txt[caijy@localhost Desktop]$ touch -d &quot;2017-06-06 12:22&quot; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Jun 6 12:22 1.txt mkdir命令用于创建空白的文件夹，格式为：“mkdir [选项] 目录”。在Linux系统中文件夹是最常见的文件类型之一，除了能创建单个目录外，还可以使用“-p”参数来递归创建出具有嵌套叠层关系的文件目录。[caijy@localhost Desktop]$ mkdir linux[caijy@localhost Desktop]$ cd linux[caijy@localhost linux]$ mkdir -p a/b/c/d[caijy@localhost linux]$ cd a[caijy@localhost a]$ cd b[caijy@localhost b]$ cp命令用于复制文件或目录，格式为：“cp [选项] 源文件 目标文件”。在Linux系统中的复制操作具体还分为3种情况，第一种情况是如果目标对象是个目录，则会把源文件复制到该目录中.，第二种情况是如果目标对象也是个普通文件，则会询问是否要覆盖它.最后是第三种的情况了，如果目标文件是不存在的，则会是正常的复制操作啦。 参数 作用 -p 保留原始文件的属性 -d 若对象为”链接文件”，则保留该”链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p,d,r为上述的参数） 首先创建一个名为install.log的普通空白文件，然后把其复制出来一份名为x.log的备份文件：[caijy@localhost Desktop]$ touch install.log[caijy@localhost Desktop]$ cp install.log x.log[caijy@localhost Desktop]$ lsinstall.log x.log mv命令用于移动文件或改名，格式为：“mv [选项] 源文件 [目标路径|目标文件名]”。剪切操作不同于复制操作，因为它会默认把源文件删除掉，操作后就只有剪切后的文件了，并且如果对一个文件在同一个目录中进行剪切操作，其实也是重命名的作用：[caijy@localhost Desktop]$ mv x.log linux.log rm命令用于删除文件或目录，格式为：“rm [选项] 文件”。使用“-i”参数删除文件时向您询问是否要执行删除操作，您可以使用“-f”参数来直接强制删除，另外想要删除一个目录文件夹的话就需要再追加一个“-r”参数才可以，否则是删除不掉的，例如来尝试删除下刚刚那两个文件吧：[caijy@localhost Desktop]$ lsinstall.log linux.log[caijy@localhost Desktop]$ rm -i install.logrm: remove regular empty file ‘install.log’? y[caijy@localhost Desktop]$ rm -rf linux.log[caijy@localhost Desktop]$ ls[caijy@localhost Desktop]$ dd命令用于指定大小的拷贝文件或指定转换文件，格式为：“dd [参数]”。dd命令是个比较重要且具有特色的一个命令，它能够让用户指定数据块的大小和个数来复制一个文件的内容，当然如果您愿意的话还可以在复制过程中转换其中的数据。Linux系统中有一个叫做/dev/zero的设备文件，这个文件不会占用您的系统存储空间，但里面却可以提供无穷无尽的数据，因此用dd命令来生成出来一个指定大小的文件是再好不过的了。 参数 作用 if 输入的文件名称。 of 输出的文件名称。 bs 设置每个“块”的大小。 count 设置要拷贝“块”的个数。 [caijy@localhost Desktop]$ dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 2.62394 s, 224 MB/s dd命令也绝对不仅限于复制文件这么简单，如果您想把一个光盘设备制作成iso格式的镜像文件，在Windows系统中一定免不了要用到第三方软件才能做到，但在Linux系统中就可以直接使用dd命令来复制并压制光盘设备变成一个可立即使用的iso镜像哦，例如：[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s file命令用于查看文件的类型，格式为：“file 文件名”。如此看来在Linux系统中文本、目录、设备等等这些一切都会可以被统称为文件，而咱们一般又不能单凭后缀就知道具体的文件类型，这时只能用file命令来查看下文件类型啦~[caijy@localhost Desktop]$ touch linux.log[caijy@localhost Desktop]$ file linux.loglinux.log: empty[caijy@localhost Desktop]$ file /dev/sda/dev/sda: block special 打包压缩与搜索命令tar命令用于对文件打包压缩或解压，格式为：“tar [选项] [文件]”。Linux系统中常见的格式比较多，主要使用的是.tar或.tar.gz或.tar.bz2格式，大部分都是由tar命令来完成的，首先“-c”参数是用于创建压缩文件的，“-x”参数是用于解压文件的，因此这两个不能同时放一起使用，其次“-z”参数是指定使用Gzip格式来压缩解压文件，“-j”参数是指定使用bzip2格式来压缩解压文件。解压时候则是根据文件的后缀来决定是何种格式参数，而有些打包操作要数个小时，屏幕没有输出的话您一定会怀疑电脑死机了，也不好判断打包的进度情况，因此非常推荐使用“-v”参数来不断显示压缩或解压的过程给用户，“-C”参数用于指定要解压到的哪个指定的目录，而“-f”参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。我会一般使用“tar -czvf 压缩包名称.tar.gz 要打包的目录”命令来把指定的文件来打包压缩，解压的话则是“tar -xzvf 压缩包名称.tar.gz”命令，接下来使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：[caijy@localhost Desktop]$ tar -czvf etc.tar.gz /etctar: Removing leading `/&#39; from member names/etc//etc/fstabtar: /etc/crypttab: Cannot open: Permission denied/etc/mtab/etc/fonts//etc/fonts/conf.d//etc/fonts/conf.d/65-0-lohit-bengali.conf...... 然后把刚刚打包的压缩包文件指定解压到mydir目录中：[caijy@localhost Desktop]$ tar -xzvf etc.tar.gz -C mydiretc/etc/fstabetc/mtabetc/fonts/etc/fonts/conf.d/etc/fonts/conf.d/65-0-lohit-bengali.conf grep命令用于对文本内容进行关键词的搜索匹配，格式为：“grep [选项] [文件]”。可以把grep命令当作是用途最广泛的文本搜索匹配工具，参数虽然很多但基本是用不到的.这里只说两个最最最常用的参数，只要会使用“-n”参数显示搜索到信息的行号，使用“-v”参数用于反选信息（即没有包含关键词的所有信息行）。Linux系统中的/etc/passwd文件是保存着所有用户信息的文件，而一旦用户的登录终端被设置成“/sbin/nologin”则不再允许登录系统，因此可以通过使用grep命令来匹配出当前系统中所有不允许登录系统的用户信息：[caijy@localhost Desktop]$ grep -n /sbin/nologin /etc/passwd2:bin:x:1:1:bin:/bin:/sbin/nologin3:daemon:x:2:2:daemon:/sbin:/sbin/nologin4:adm:x:3:4:adm:/var/adm:/sbin/nologin5:lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin...... find命令用于在Linux系统中按照指定条件查找文件，格式为：“find [查找路径] 寻找条件 操作”。“Linux系统中的一切都是文件”，在Linux系统中的搜索工作一般都是通过find命令来完成的，它可以根据不同的文件特性来做为匹配项（如文件名、大小、修改时间、权限等信息），一旦匹配到了则会默认为用户显示到屏幕上来，基础的匹配项目请见下表即可。我主要讲解下“–exec”参数重要的作用，这个参数是用于把find命令搜索到的结果交由给后面的命令再进一步做处理，十分类似于后面博文提到的管道符技术。 参数 作用 -name 匹配名称 -perm 匹配权限（mode为完全匹配，-mode为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime 匹配修改内容的时间（-n指n天以内，+n指n天以前） -atime -n +n 匹配访问文件的时间-n指n天以内，+n指n天以前 -ctime -n +n 匹配修改权限的时间-n指n天以内，+n指n天以前 -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件f1新却比f2旧的文件 –type b/d/c/p/l/f 匹配文件类型（块设备、目录、字符设备、管道、链接文件、文件文件） -size 匹配文件的大小（+50k查找超过50k的文件,而-50k则代表查找小于50k的文件） -prune 忽略某个目录 -exec {} \; 后面可接对搜索到结果进一步处理的命令（下面会有演示） Linux系统中的配置文件根据FHS协议会被保存到/etc目录中，如果要想获取到该目录中所有以host开头的文件列表就可以这样做：[caijy@localhost Desktop]$ sudo find /etc -name &quot;host*&quot; -print[sudo] password for caijy:/etc/avahi/hosts/etc/host.conf/etc/hosts 想要在整个系统中搜索所有权限中包括SUID权限的文件，只需使用减号-4000即可：[caijy@localhost Desktop]$ sudo find / -perm -4000 -print/usr/bin/fusermount/usr/bin/su/usr/bin/chage/usr/bin/gpasswd......]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程01]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B01%2F</url>
    <content type="text"><![CDATA[经济有限，笔者在虚拟机上安装的“红帽”，具体安装步骤在此不展开论述，不会的同学参考虚拟机/红帽安装及工具下载。 重置root用户密码记得笔者一次面试的时候被问到：如果忘记MySQL root用户的密码怎么办？我一想，这种问题就该直接谷歌，结果被鄙视一脸。后来查了一下，无非是几个命令。在此记录这个比较重要的问题，此处以红帽系统为例（大家先确认自己的Linux系统是不是红帽）： 重启Linux，在引导界面按“e” 在linux16参数这行的后面追加“rd.break”参数并同时一起按下键盘“ctrl“和“x”按键来执行内核参数 过一会儿便进入系统的紧急求援模式。依次输入一下命令（其中第三行命令的“123456”是你新的root用户密码）： mount -o remount,rw /sysroot chroot /sysroot echo “123456” | passwd –stdin root touch /.autorelabel exit reboot然后等待重启即可 RPM红帽软件包这里总结一下常用的软件包命令： 安装软件的命令格式:rpm -ivh filename.rpm 升级软件的命令格式:rpm -Uvh filename.rpm 卸载软件的命令格式:rpm -e filename.rpm 查询软件的描述信息的命令格式:rpm -qpi filename.rpm 列出软件的文件信息的命令格式:rpm -qpl filename.rpm 查询文件属于哪个RPM的命令格式:rpm -qf filename Yum软件仓库Yum软件仓库是为了进一步降低软件安装难度和复杂度而设计的技术，Yum软件仓库可以根据用户的要求分析出所需软件包及其相关依赖关系，然后自动从服务器下载软件包并安装到系统，下面的Yum命令过一下即可。 命令 作用 yum repolist all 列出所有仓库 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 yum remove 软件包名称 移除软件包 yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove 软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 Systemd初始化进程Linux操作系统开机过程首先从BIOS开始，进入“Boot Loader”，加载系统内核，，内核进行初始化，启动初始化进程。初始化进程作为系统第一个进程，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。systemd初始化进程服务采用了并发启动机制，开机速度得到了不小的提升。红帽RHEL7系统启动时要做大量的初始化工作，例如挂在文件系统和交换分区。启动各类进程服务等操作，这些都可以看作一个个的单元（Unit），即用”目标(target)”代替了“运行级别”这个概念，区别如下表所示： Sysvinit运行级别 System目标名称 作用 0 runlevel0.target, poweroff.target 关机 1 runlevel1.target, rescue.target 单用户模式 2 runlevel2.target, multi-user.target 等同于级别3 3 runlevel3.target, multi-user.target 多用户的文本界面 4 runlevel4.target, multi-user.target 等同于级别3 5 runlevel5.target, graphical.target 多用户的图形界面 6 runlevel6.target, reboot.target 重启 emergency emergency.target 紧急Shell 红帽RHEL6系统使用service、chkconfig等命令来管理系统服务，红帽RHEL7系统中管理服务使用的是systemctl命令：systemctl管理服务的启动、重启、停止、重载、查看状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 service foo start systemctl start foo.service 启动服务 service foo restart systemctl restart foo.service 重启服务 service foo stop systemctl stop foo.service 停止服务 service foo reload systemctl reload foo.service 重新加载配置文件（不终止服务） service foo status systemctl status foo.service 查看服务状态 systemctl设置服务的开机启动、不启动、查看各级别下服务启动状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 chkconfig foo on systemctl enable foo.service 开机自动启动 chkconfig foo off systemctl disable foo.service 开机不自动启动 chkconfig foo systemctl is-enabled foo.service 查看特定服务是否为开机自启动 chkconfig –list systemctl list-unit-files –type=service 查看各个级别下服务的启动与禁用情况]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Linux Blog]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。 –《Linux就该这么学》读书笔记]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
