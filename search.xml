<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础课程05]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F15%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B05%2F</url>
    <content type="text"><![CDATA[Linux系统具有多用户、多任务的历史发展特点，所以也迫使其具有了很好的安全性，保障Linux系统安全的背后是复杂的配置工作。这一节我们学习Linux系统中文件的 所有者、所有组以及其他人 所对应的读(r)写(w)执行(x)的一般权限的作用，会添加、删除、修改用户帐户信息。咱们还可以使用 SUID、SGID与SBIT特殊权限位 让系统权限功能更加的灵活，弥补单纯对文件设置一般权限的功能不足。隐藏权限 能够让系统多一层隐形的防护层，让黑客对关键日志信息最多只能看，而不能修改或删除。通过 ACL访问控制列表 再进一步的针对单一用户、用户组对单一文件或目录进行特殊的权限安排，让文件的权限最大限度满足工作的需求。最后还将学习到使用 su命令与sudo服务 来让普通用户既能够使用到超级管理员的权限来满足日常的工作需求还兼顾系统的安全性，最佳搭配方案。 用户身份与能力安装红帽REHL7操作系统时特别要求设置root用户密码，这个root用户就是存在所有类UNix系统的 超级用户，拥有最高的系统所有权，能够管理系统的各项能力，比如 添加/删除用户，启动/关闭服务进程，开启/禁用硬件设备 等权限。虽然使用root用户工作时不会受到系统的种种限制，但老话讲能力越大，责任越大，一旦使用这个高能的root用户执行了错误的命令有可能会直接回调整个系统~ Linux系统的超级用户之所以是root，并不是因为它的名字叫root，而是因为该用户身份号码——即UID(User IDentification)的数值为0，在Linux系统中的UID就相当于人类社会中的身份证号码一样权威、唯一性，因此Linux系统是通过用户的UID的值来判断用户身份，RHEL7系统中的用户身份包括有： 超级用户UID0：系统的超级用户 系统用户UID1-999：系统中程序服务由不同用户运行，更加安全，默认被限制不能登录系统 普通用户UID1000-：即管理员创建的用于日常工作而不能管理系统的普通用户。 注意UID一定是不能冲突的，管理员创建的普通用户UID从1000开始，即便前面有闲置的号码。 为了方便管理同一组的用户还有一个用户组的概念，用户组号码——GID（Group IDentification），使得咱们可以把多个用户加入到同一个组中，方便统一规划权限或任务，想象公司中有多个部门，而每个部门中又有很多同事，那么如果只想让员工获取到本部门内的共享资源，则就可以针对部门设置权限，而非针对于某个人，例如只有属于技术部分组的人才可以访问公司的数据库信息等等。另外在Linux系统中每个用户在建立时也会自动创建一个与其同名的 基本用户组，这个基本用户组只有该用户一个人，而该用户以后被归纳入的用户组则叫做 扩展用户组，因此一个用户只有一个基本用户组，而可以有多个扩展用户组，来满足日常的工作需要。 useradd命令用于创建新的用户，格式为：“useradd [选项] 用户名”。可以使用这个命令来创建用户账户，默认的用户家目录会被存放在/home目录，默认的Shell解释器是/bin/bash，默认会创建一个与该用户同名的基本用户组以及默认该用户不包含其他的扩展用户组，这些默认值可以依据下面useradd命令的参数来自行修改： 参数 作用 -d 指定用户的家目录（默认为/home/username） -e 账号有效截至日期，格式：YYYY-MM-DD. -u 指定该用户的默认UID -g 指定该用户的默认UID -G 指定一个或多个扩展用户组 -N 不创建与用户同名的基本用户组 -s 指定该用户的默认Shell 创建一个普通用户并指定家目录路径、UID用户身份号码以及Shell解释器，其中/sbin/nologin是终端解释器的一员，它与bash解释器有着天壤之别，因为一旦用户的解释器被设置成了nologin，那么则代表该用户不能登录到系统：[root@caijy Desktop]# useradd -d /home/linux -u 8888 -s /sbin/nologin linuxprobe[root@caijy Desktop]# id linuxprobeuid=8888(linuxprobe) gid=8888(linuxprobe) groups=8888(linuxprobe) groupadd命令用于创建群组，格式为：”groupadd [选项] 群组名”。为了能够让系统中各个用户的权限指派更加的有效率，工作中常常会把几个用户组设置成某个用户的扩展用户组，这样的话就可以针对于一类用户进行统一的权限安排了，而这个步骤非常的简单，例如创建一个名字叫做ronny的用户组：[root@caijy Desktop]# groupadd ronny usermod命令用于修改用户的属性，格式为“usermod [选项] 用户名”。在Linux系统中一切都是文件，因此在系统中创建用户也是修改配置文件的过程，用户的信息被保存在/etc/passwd文件中，可以直接使用文本编辑器来修改其中的数值项目，也可以用usermod命令来修改已经创建的用户信息项目，诸如用户身份号码、基本/扩展用户组、默认终端等等： 参数 作用 -c 填写帐号的备注信息 -d -m -m与-d连用，可重新指定用户的家目录并自动把旧的数据转移过去。 -e 账户到期时间，格式“YYYY-MM-DD” -g 变更所属用户组 -G 变更扩展用户组 -L 锁定用户禁止其登陆系统 -U 解锁用户，允许其登陆系统 -s 变更默认终端 -u 修改用户UID 不要被这么多参数吓坏啦~先来看下某个帐户的默认信息：[root@caijy Desktop]# id caijyuid=1000(caijy) gid=1000(caijy) groups=1000(caijy),10(wheel)接下来学习如何为用户增添到一个额外的扩展用户组中，以及修改该用户的身份号码：[root@caijy Desktop]# usermod -G root linuxprobe[root@caijy Desktop]# id linuxprobeuid=8888(linuxprobe) gid=8888(linuxprobe) groups=8888(linuxprobe) 0(root)[root@caijy Desktop]# usermod -u 8889 linuxprobe[root@caijy Desktop]# id linuxprobeuid=8889(linuxprobe) gid=8888(linuxprobe) groups=8888(linuxprobe),0(root) passwd命令用于修改用户的密码，格式为：“passwd [选项] [用户名]”。该命令用于修改用户的密码，，过期时间，认证信息等，普通的用户只有权限修改自身的系统密码，而超级用户则有权限来修改其它所有人的密码。更酷的是Linux系统中root管理员修改自己或他人的密码是不需要验证旧密码的，这点特别的方便。既然root用户都有权限修改或登录了该用户，就代表已经对该用户有完全的管理权限了，因此尝试修改该用户密码时不再重复要求验证旧密码其实也并不存在安全隐患： 参数 作用 -l 锁定用户禁止其登录 -u 解除锁定，允许用户登录 –stdin 允许从标准输入修改用户密码，如(echo “NewPassWord” &#124; passwd –stdin Username) -d 使账号无密码 -e 强制用户下次登陆时修改密码 -S 显示用户的密码状态 接下来学习如何修改用户自己的密码，以及如何修改其他人的密码（该动作仅限root管理员用户可使用）：[root@caijy Desktop]# passwdChanging password for user root.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully.[root@caijy Desktop]# passwd linuxprobeChanging password for user linuxprobe.New password:BAD PASSWORD: The password is shorter than 8 charactersRetype new password:passwd: all authentication tokens updated successfully.当有个同事请了长假时，还可以用这个命令来禁止或允许某个用户登录到本系统，而不是删除该用户，这样既保证了这段时间内系统的安全，也避免频繁添加、删除用户带来的麻烦：[root@caijy Desktop]# passwd -l linuxprobeLocking password for user linuxprobe.passwd: Success[root@caijy Desktop]# passwd -S linuxprobelinuxprobe LK 2017-09-15 0 99999 7 -1 (Password locked.)[root@caijy Desktop]# passwd -u linuxprobeUnlocking password for user linuxprobe.passwd: Success[root@caijy Desktop]# passwd -S linuxprobelinuxprobe PS 2017-09-15 0 99999 7 -1 (Password set, SHA512 crypt.) userdel命令用于删除用户，格式为：“userdel [选项] 用户名”。如果咱们确认以后不需要再让某个用户登录到本地系统中，则可以通过userdel命令来删除有关该用户的所有信息，默认该用户的家目录数据会被保留下来，而如果想要一起删除的话可以加上 -r 参数即可：[root@caijy Desktop]# id linuxprobeuid=8889(linuxprobe) gid=8888(linuxprobe) groups=8888(linuxprobe),0(root)[root@caijy Desktop]# userdel -r linuxprobe[root@caijy Desktop]# id linuxprobeid: linuxprobe: no such user 文件权限与归属Linux系统中一切都是文件，但每个文件的类型不尽相同，并且Linux系统会用不同的符号进行区分，常见的包括有： -:普通文件, d:目录文件, l:链接文件, b:块设备文件, c:字符设备文件, p:管道文件每个文件都有其相对应的所有者和所有组，还有分别规定对所有者、所有组和其他人的可读、可写、可执行的权限。对于一般文件来讲的权限比较好理解，可读权限就是能够读取该文件的实际内容，可写权限就是能够编辑、新增、修改文件的实际内容，可执行则代表能够运行一个脚本程序的权限。但对于目录文件的权限设置就不太好掌握了，首先对于目录文件的可读权限就是能够读取该目录内的结构和文件列表，可写权限就是能够更改目录内文件结构列表，新增，删除，重命名文件，而可执行的实质是代表进入该目录的权限。 读(read)，写(write)，执行（execute）简写即为 (r,w,x)，亦可用数字 (4,2,1) 表示，如下表：数字法是基于rwx的权限计算而来，主要是为了简化权限的表示信息。举例来说若某个文件的权限为7则代表可读，可写，可执行(4+2+1)，若权限为6则代表可读，可写(4+2)。因此例如说一个文件可以让所有者可读可写也可执行，对于文件的所属组来讲可读可写，而除了所有者和所有组以外的其他人则只有可读的权限，那么权限就是rwxrw-r–，数字法表示即为764，不过千万别算出来7+6+4=17，这是小学的数学加减法，不是Linux系统的权限数字法，三组之间没有相通关系。 下面一起分析下图的文件信息：图中所示包括有文件的类型、访问权限、所属者（属主）、所有组（属组）、占用大小、修改时间和文件名称等信息。通过分析可得知该文件类型为一般文件，所有者权限为可读可写（rw-），所有组权限为可读（r–），除此以外的其他人也只有可读权限（r–），文件的磁盘占用大小是34298字节，最近一次的修改时间为4月2日的凌晨23分，文件的名称为install.log。 文件的特殊权限在复杂多变的生产环境中，单纯对文件设置rwx权限肯定不能满足咱们对安全、便捷工作的需求，因此便有了SUID、SGID与SBIT的特殊权限机制。特殊权限位是针对于文件设置的一种特殊的功能，而且与一般权限可同时出现使用，用于弥补一般权限不能实现的功能。SUID:让执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效）考虑下面一种情形，我们知道在Linux系统中，所有的账号密码都记录在/etc/shadow这个文件中，这个文件的权限为———- 1 root root，也就是说只有root用户才能修改这个文件，但是我们一般账号可使用passwd命令来修改密码，从而修改这个文件，这是怎么做到呢？答案就是SUID。该权限仅在执行该程序的过程中（run-time）有效[root@caijy Desktop]# ls -l /etc/shadow----------. 1 root root 1891 Sep 15 11:12 /etc/shadow[root@caijy Desktop]# ls -l /bin/passwd-rwsr-xr-x. 1 root root 27832 Jan 30 2014 /bin/passwd SGID功能一：让执行者临时拥有属组的权限（对拥有执行权限的二进制程序设置）这种特殊权限就是参考SUID而设计的，不同点就是让程序的执行者获取的不再是文件所有者的临时权限，而是获取到文件的所有组的权限。举例来说，在早期的Linux系统中/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为： cr–r—– 1 root system 2, 1 Feb 11 2017 kmem 也就是除了root超级用户身份或属于system组成员外的所有用户都没有读取该文件的权限，但平时咱们需要查看系统进程状态，为了让用户能够获取到系统状态信息，因此将用于查看系统进程状态的ps命令权限上增加了SGID特殊权限位： -r-xr-sr-x 1 bin system 59346 Feb 11 2017 ps 这样的话因为ps命令被赋予了SGID特殊权限位，所以当用户执行了该命令，实际上临时获取到了有效用户组system的权限啦，能够顺利的读取设备文件啦~ SGID功能二：在该目录中创建的文件自动继承此目录的用户组（只可以对目录设置）正如前面提到过每个文件都有其归属的所有者和所有组，而当创建或传送一个文件后，这个文件就会自动的归属于执行这个操作的用户。那么比如工作中需要设置一个部门内的共享目录，让所有组内的人都能够读取里面的内容，那么咱们就可以创建部门共享目录后，把该目录设置上SGID特殊权限位，这样任何用户在里面创建的任何文件都会归属于本目录的所有组，而不再是自己的基本用户组。[root@caijy ~]# cd /tmp[root@caijy tmp]# mkdir testdir[root@caijy tmp]# ls -ald testdir/drwxr-xr-x. 2 root root 6 Sep 15 15:04 testdir/[root@caijy tmp]# chmod -Rf 777 testdir/[root@caijy tmp]# chmod -Rf g+s testdir/[root@caijy tmp]# ls -ald testdir/drwxrwsrwx. 2 root root 6 Sep 15 15:04 testdir/这样设置好777权限以保证普通用户可以写入文件，并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户尝试在该目录创建文件，看看新建出来的文件是否会继承上级目录的所有组名称：[root@caijy tmp]# su - caijyLast login: Fri Sep 15 10:30:27 CST 2017 on :0[caijy@caijy ~]$ cd /tmp/testdir[caijy@caijy testdir]$ echo &quot;linux&quot; &gt; test[caijy@caijy testdir]$ ls -al test-rw-rw-r--. 1 caijy root 6 Sep 15 15:11 test chmod命令用于修改文件或目录的权限，格式为：”chmod [参数] 权限 文件或目录名称”。这是一个非常实用的命令，能够用来设置文件或目录的权限，例如想要把一个文件的权限设置成所有者都可以可读写执行、所有组可读写而其他人没有任何权限，这样对应起来就是rwxrw—-，用数字法来设置也就是760啦，于是通过前面的基础学习到当前实践操作，同学们马上就能感受到了数字法设置权限的便捷性了吧~[root@caijy ~]# cd /tmp/testdir[root@caijy testdir]# ls -al test-rw-rw-r--. 1 caijy root 6 Sep 15 15:11 test[root@caijy testdir]# chmod 760 test[root@caijy testdir]# ls -al test-rwxrw----. 1 caijy root 6 Sep 15 15:11 test chown命令用于修改文件或目录的所属主与所属组，格式为：“chown [参数] 所属主:所属组 文件或目录名称”。除了修改文件的权限外，还可以使用chown命令来设置文件的所有者和所有组。chmod和chown命令是对文件属性和权限修改最常用的命令，它们还有一个特别的共性，就是对于目录文件时需要加上大写参数-R来表示递归操作，即对目录内所有的文件进行整体操作的意思。[root@caijy testdir]# ls -l test-rwxrw----. 1 caijy root 6 Sep 15 15:11 test[root@caijy testdir]# chown root:bin test[root@caijy testdir]# ls -l test-rwxrw----. 1 root bin 6 Sep 15 15:11 test SBIT(Sticky Bit):只可管理自己的数据而不能删除他人文件(仅对目录有效)SBIT特殊权限位的设置目的和效果是不让其他人删除自己的文件，换句话说就是文件只能被所有者执行删除操作。在RHEL7系统中的/tmp作为一个共享文件的目录默认已经被设置了SBIT特殊权限位，因此这里面的文件其他人是不能乱删除的：[andy@caijy tmp]$ su - caijyPassword:Last login: Fri Sep 15 15:25:26 CST 2017 on pts/0[caijy@caijy ~]$ ls -ald /tmpdrwxrwxrwt. 16 root root 4096 Sep 15 15:30 /tmp[caijy@caijy ~]$ cd /tmp[caijy@caijy tmp]$ ls -alddrwxrwxrwt. 16 root root 4096 Sep 15 15:30 .[caijy@caijy tmp]$ echo &quot;Welcome to linux&quot; &gt; test[caijy@caijy tmp]$ chmod 777 test[caijy@caijy tmp]$ ls -ald test-rwxrwxrwx. 1 caijy caijy 17 Sep 15 15:31 test其实文件能否被删除并不取决于自身的权限大小，而是看上级目录是否有写入权限，这个是前面提到过的，但为了避免很多同学不放心，所以还是赋予了这个文件最大的777权限(rwxrwxrwx)。切换到另外一个普通用户然后尝试删除这个别人的文件就会发现，即便权限十分的充足，但是由于SBIT特殊权限位的缘故依然导致了无法删除其他人的文件：[caijy@caijy tmp]$ su - andyPassword:Last login: Fri Sep 15 15:29:12 CST 2017 on pts/0[andy@caijy ~]$ cd /tmp[andy@caijy tmp]$ rm -f testrm: cannot remove ‘test’: Operation not permitted 文件的隐藏属性在Linux系统中除了能对文件设置一般权限和特殊权限外还有一种叫做隐藏权限的功能，顾名思义就是被隐藏起来的权限，即在默认情况下是不能直接被用户发觉的。在真实的工作环境和红帽RHCE考试题目中碰到过明明权限很充足但却不能删除某个文件的情况，或者仅仅能对日志文件进行追加内容而不能删除或减少，一定程度上阻止了黑客篡改系统日志的图谋，因此这种很“奇怪”的文件让Linux系统更加的安全。 chattr命令用于设置文件的隐藏权限，格式为：“chattr [参数] 文件”。可以使用chattr命令来设置文件的隐藏权限，如果想要把某个隐藏功能添加到文件上面，则使用 +参数，如果想要把某个隐藏功能移出文件，则使用 -参数。可供咱们选择的隐藏权限功能非常丰富，常见的隐藏权限包括有： 参数 作用 i 将无法对文件进行修改,若对目录设置后则仅能修改子文件而不能新建或删除。 a 仅允许补充（追加）内容.无法覆盖/删除(Append Only)。 S 文件内容变更后立即同步到硬盘(sync)。 s 彻底从硬盘中删除，不可恢复(用0填充原文件所在硬盘区域)。 A 不再修改这个文件的最后访问时间（atime） b 不再修改这个文件的存取时间 D 检查压缩文件中的错误 d 当使用“dump”命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除此文件后依然保留其在硬盘中的数据，以便日后恢复 t 让文件系统支持尾部合并（tail-merging） X 直接访问压缩文件中的内容 为了能更好的见识到隐藏权限的效果，先来创建一个普通文件后立即尝试删除，这个肯定是毫无悬念会成功的：[root@caijy ~]# echo &quot;for test&quot; &gt; test[root@caijy ~]# rm testrm: remove regular file ‘test’? y实践是检验真理的唯一标准，如果没有亲眼见见隐藏权限强大功能的美妙，就一定不会相信原来Linux系统会如此的安全且复杂。当咱们再次新建了一个普通文件并设置了不允许删除与覆盖(+a参数)权限后的效果：[root@caijy ~]# echo &quot;for test&quot; &gt; test[root@caijy ~]# chattr +a test[root@caijy ~]# rm testrm: remove regular file ‘test’? yrm: cannot remove ‘test’: Operation not permitted lsattr命令用于显示文件的隐藏权限，格式为：“lsattr [参数] 文件”。对于Linux系统中的隐藏权限必须用lsattr命令才能够看到，平时使用的ls之类的命令是看不出异样的：[root@caijy ~]# ls -al test-rw-r--r--. 1 root root 9 Sep 15 15:50 test一旦使用了lsattr命令后文件上被赋予的隐藏权限就会马上原形毕露出来，只需要按照提示的隐藏权限的类型（字母）来使用chattr命令去掉即可：[root@caijy ~]# lsattr test-----a---------- test[root@caijy ~]# chattr -a test[root@caijy ~]# lsattr test---------------- test[root@caijy ~]# rm testrm: remove regular file ‘test’? y 文件访问控制列表不知大家有没有发现其实上面讲到的一般权限、特殊权限、隐藏权限其实有个共性——权限是针对某一类用户设置的。而如果希望对某个指定的用户进行单独的权限控制，那么就需要用文件的访问控制列表来实现啦。基于普通文件或目录设置ACL访问控制策略，通俗来说就是设置指定的特定用户或用户组对某个文件的操作权限，另外如果对某个目录设置了访问控制策略，那么子文件则继承其访问策略，而若对文件设置了访问控制策略则不再继承上级目录的控制策略。 为了更直观的看到ACL访问控制列表对文件权限控制的强大效果，因此先切换到普通用户后尝试进入到root超级用户的家目录中：[root@caijy ~]# su - caijyLast login: Fri Sep 15 15:30:25 CST 2017 on pts/0[caijy@caijy ~]$ cd /root-bash: cd: /root: Permission denied[caijy@caijy ~]$ exitACL提供的是在所有者，所有组，其它人的读写执行权限外的特殊权限控制，使用setfacl命令可以让咱们能够针对单一用户或用户组，单一文件或目录来进行读写执行权限的控制，其中对于目录文件需要用到递归-R参数，对普通文件需要用到-m参数，而如果想要删除某个文件的访问控制策略的话可以使用-b参数，于是快来设置下用户在/root目录上面的权限吧：[root@caijy ~]# setfacl -Rm u:caijy:wrx /root[root@caijy ~]# su - caijyLast login: Fri Sep 15 16:05:49 CST 2017 on pts/0[caijy@caijy ~]$ cd /root[caijy@caijy root]$ lsanaconda-ks.cfg initial-setup-ks.cfg[caijy@caijy root]$ cat anaconda-ks.cfg#version=RHEL7# System authorization informationauth --enableshadow --passalgo=sha512...... 是不是觉得效果很酷呢？但是又遇到了一个小问题——怎么样去查看文件上面有那些ACL策略呢？常用的ls命令是看不到访问控制列表信息的，但是却可以看到文件的权限最后一个点(.)变成了加号（+）,而这就意味着这个文件已经被设置有了ACL访问策略啦。现在是不是感觉学得越多，越不敢说自己精通于Linux系统了呢？这么一个不起眼的点(.)竟然还意味着这么一种重要的权限呢。[caijy@caijy root]$ ls -ld /rootdr-xrwx---+ 5 root root 4096 Sep 15 15:53 /root getfacl命令用于显示文件的ACL规则，格式为：”getfacl 文件名称”。在Linux系统中的命令就是这么又可爱又好记，想要设置ACL访问策略的话就是setfacl命令，而查看ACL访问策略的话就是getfacl命令。使用getfacl命令能够显示出在文件上设置的所有访问策略规则信息。[caijy@caijy root]$ getfacl /rootgetfacl: Removing leading &#39;/&#39; from absolute path names# file: root# owner: root# group: rootuser::r-xuser:caijy:rwxgroup::r-xmask::rwxother::--- su命令与sudo服务使用su命令可以让使用者在不注销的情况下顺畅的切换至其他用户，例如从root超级用户切换至普通用户：[root@caijy ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[root@caijy ~]# su - caijyLast login: Fri Sep 15 16:14:54 CST 2017 on pts/0[caijy@caijy ~]$ iduid=1000(caijy) gid=1000(caijy) groups=1000(caijy),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023细心的同学一定会发现上面的su命令与用户名之间有一个减号(-)，这意味着完全的切换到新的用户，即把环境变量信息也变更为新的用户，而不保留原始的用户信息，这个是推荐必加的参数，一定要记下哦~另外当超级用户切换到普通用户时是不需要密码验证的，而普通用户切换成超级用户身份就需要密码验证后才能成功了，这是一个必要的安全检查：[caijy@caijy ~]$ su - rootPassword:Last login: Fri Sep 15 16:20:16 CST 2017 on pts/0[root@caijy ~]# su - caijyLast login: Fri Sep 15 16:20:27 CST 2017 on pts/0[caijy@caijy ~]$ exitlogout[root@caijy ~]#虽说像上面使用su命令允许普通用户完全变更为root用户身份来完成工作，但这也无疑会暴露了root超级管理员的密码，使得系统密码被黑客获取的几率也大大提高了，这似乎并不是最安全的方案。因此我们来学习使用sudo程序来把特定命令的执行权限赋予给指定的用户，这样既可保证了正常工作的同时也避免了泄露root超级用户密码，平时只要合理的配置sudo服务便可以合理的兼顾系统的安全性和用户便捷性，配置的原则也很简单—— 在保证普通用户完成工作的前提下，尽可能少的给予额外的权限，总结来说sudo服务程序的特色功能有： 限制用户执行指定的命令。 记录用户执行的每一条命令。 配置文件（/etc/sudoers）提供集中的管理用户、权限与主机等参数。 验证过密码后5分钟(默认值)内无须再让用户验证密码，更加的方便。 sudo服务用于给普通用户提供额外权利来完成原本超级用户才能完成的任务，格式为：“sudo [参数] 命令名称”。 参数 作用 -h 列出帮助信息 -l 列出当前用户可执行的命令 -u 用户名或UID值 以指定的用户身份执行命令 -k 清空安全时间，下次执行sudo时需要再次验证密码 -b 在后台执行指定的命令 -p 更改询问密码的提示语 当然如果感觉直接修改配置文件不太放心，担心出现问题的话还可以使用sudo服务提供的visudo命令来配置用户权限，这条命令在配置用户权限时可以避免多个用户同时修改配置文件，以及对配置文件内的参数进行语法检查，在发现错误参数时会直接提示并报错。 只用超级用户才可以使用visudo命令编辑sudo程序的配置文件（/etc/sudoers），平时还可以使用visudo命令来配置用户权限吧，这样既能防止多个用户同时修改配置文件，还能对配置文件内的参数进行语法检查，对于错误的参数会直接提示并报错：visudo: &gt;&gt;&gt; /etc/sudoers: syntax error near line 111 &lt;&lt;&lt;What now?Options are:(e)dit sudoers file again(x)it without saving changes to sudoers file(Q)uit and save changes to sudoers file (DANGER!) 使用visudo命令配置sudo服务的服务文件时，操作的方法与咱们学习过的vim编辑器是一致的，因此在编写完成后记得在末行模式下保存并退出。sudo服务程序配置文件中约第99行按照下面的格式填写上指定的信息即可： 谁可以使用超级用户身份 允许使用sudo命令的主机=（以谁的身份执行命令） 可执行命令的列表[root@caijy ~]# visudo## Allow root to run any commands anywhereroot ALL=(ALL) ALLcaijy ALL=(ALL) ALL这样填写后记得要保存后再退出，然后切换至指定的用户身份就可以用sudo -l命令查看到所有可执行的命令啦（此处验证的是该普通用户的密码，而不是root用户的密码，同学们不要搞混喽）：[root@caijy ~]# su - caijyLast login: Fri Sep 15 16:22:01 CST 2017 on pts/0[caijy@caijy ~]$ sudo -l[sudo] password for caijy:Matching Defaults entries for caijy on this host:requiretty, !visiblepw, always_set_home, env_reset, env_keep=&quot;COLORSDISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;, env_keep+=&quot;MAIL PS1PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;, env_keep+=&quot;LC_COLLATELC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;,env_keep+=&quot;LC_MONETARYLC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;, env_keep+=&quot;LC_TIME LC_ALLLANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;,secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin User caijy may run the following commands on this host:(ALL) ALL(ALL) ALL接下来就是见证奇迹的时刻，因为作为一名普通用户是肯定不能查看到root超级用户家目录(/root)中的文件信息的，但咱们只需要在想执行的命令前面加上sudo命令就变得有权限了：[caijy@caijy root]$ ls /rootls: cannot open directory /root: Permission denied[caijy@caijy root]$ sudo ls /root[sudo] password for caijy:anaconda-ks.cfg initial-setup-ks.cfg效果非常明显哦！但是考虑到真实的工作环境中肯定不能允许某个普通用户拥有了整个系统中所有命令的最高执行权，也不符合刚刚提到的权限赋予原则——在保证普通用户完成工作的前提下，尽可能少的给予额外的权限，因此ALL的参数就显得有些不合适了，应该代之以具体的命令来既让用户满足了工作需求，也能够受到必要的权限约束。如果需要让某个用户只能使用超级用户的身份执行指定的命令，切记一定要写上的是该命令的绝对路径，否则系统会识别不出来哦，咱们可以先用whereis命令找出命令所对应的保存路径，然后把刚刚配置文件中约第99行的用户权限参数修改成对应的路径即可：[root@caijy ~]# whereis catcat: /usr/bin/cat /usr/share/man/man1/cat.1.gz /usr/share/man/man1p/cat.1p.gz[root@caijy ~]# visudo## Allow root to run any commands anywhereroot ALL=(ALL) ALLcaijy ALL=(ALL) /bin/cat这样编辑好后依然是记得要保存退出，然后咱们再次切换到指定的普通用户上面，尝试正常查看某个文件的内容被提示没有权限，然后再用sudo命令后就可以顺利的查看文件内容啦：[root@caijy ~]# su - caijyLast login: Fri Sep 15 16:46:38 CST 2017 on pts/0[caijy@caijy ~]$ cat /etc/shadowcat: /etc/shadow: Permission denied[caijy@caijy ~]$ sudo cat /etc/shadow[sudo] password for caijy:root:$6$dVUdyi82$u11lUZwsCwYv92m92nCjP9My1dT.QH.j463.MUeREj5C6pkOmNpY2ugpg5pGJ2kXrphOC7qFViD8mrfvZs.9W/:17424:0:99999:7:::bin:*:16141:0:99999:7:::......这样当咱们切换到普通用户后再执行命令时，就不用再频繁麻烦的要求验证密码了，在日常工作会一定会感觉到痛快极了~ 转载自：http://www.linuxprobe.com/chapter-05.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程04]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F14%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B04%2F</url>
    <content type="text"><![CDATA[首先来学习如何使用vim编辑器来编写、修改文档，然后通过逐个配置主机名称、系统网卡以及Yum仓库参数文件等实验来加深对vim编辑器中诸多命令、快捷键的执行方法与各个模式切换的方法。然后把前面的Linux命令、命令语法与Shell脚本中的if条件测试语句、for条件测试循环语句、while条件循环语句以及case条件测试语句通过vim编辑器写到Shell脚本中结合到一起，实现最终能够自动化工作的软件脚本工具。最后为读者们演示了怎样通过at命令与crond计划任务服务来分别实现一次性与长期性的系统任务设置方法，让日常的工作更加高效自动化，一劳永逸。 Vim文本编辑器“Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中也一定免不了遇到编写文档的事情吧，这些都是要通过文本编辑器来完成的，咱们选择学习vim这个当前整个linux操作系统中都会默认安装好的一款超棒文本编辑器，学会后绝对会能让您“通吃”当前主流的系统。Vim能够得到广大厂商与众多用户的认可，原因就是在Vim编辑器中内设有的三种模式——命令模式、末行模式 和 编辑模式，每种模式分别又支持多种不同的命令快捷键组合，大大的提高了工作效率，用习惯后会觉得非常的顺手。而要想在文本操作时更加高效率，就必须先搞清Vim编辑器的三种模式的操作不同与切换方法： 命令模式：控制光标移动，可对文本进行删除、复制、粘贴和查找等工作。 输入模式：正常的文本录入。 末行模式：保存、退出与设置编辑环境。 每次运行vim编辑器后都默认会是 “命令模式”，需要先进入到 “输入模式” 后再进行编写文档的工作，而每次编辑完成需先返回到 “命令模式” 后再进入 “末行模式” 中执行对文本的保存或退出操作，并不能直接从 “输入模式” 切换到 “末行模式” 。vim编辑器内设支持的命令有成百上千种用法，为了能够帮助读者更快的掌握vim编辑器，刘遄老师分别总结了在 命令模式 和 末行模式 中最常用的一些快捷键命令，如下表所示： 命令 作用 dd 删除（剪切）光标所在整行。 5dd 删除(剪切)从光标处开始的5行。 yy 复制光标所在整行 5yy 复制从光标处开始的5行。 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后。 /字符串 在文本中从上至下搜索该字符串。 ?字符串 在文本中从下至上搜索该字符串。 末行模式主要用于保存或退出文件，能够设置vim编辑器的整体使用环境，还可以让用户执行外部Linux命令或跳转到特定的行数，切换到末行模式的方式就是在命令模式中输入一个冒号就可以的，末行模式中可用的命令如下表： 命令 作用 :w 保存 :q 推出 :q! 强制推出 :wq! 强制保存退出 :set nu 设置行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two 编写简单文档现在就让咱们一起动手编写个简单的文档吧，编写脚本的第1步就是给文件取个名字，如果文档的名称存在则打开它，如果不存在则是创建一个临时的输入文件。[root@localhost workdir]# vim practice.txt进入文件后默认看到的是vim编辑器的命令模式，这时只能够执行命令快捷键而不能随意输入文本内容，必须切换到输入模式才可以开始编写工作。有些读者应该能够猜出a、i、o三键的区别了吧，对，就是光标的位置不同！a键与i键分别是在光标右一位和光标当前位置切换到输入模式，而o键则是在光标的下面再创建一个空行，此时可敲击a键进入到编辑器的输入模式，输入模式是可以随意输入文本内容的，更不会把您输入的文本内容当作命令而执行:如果想要保存并退出这个文本文件，必须先从 输入模式 返回到 命令模式，然后切换至 末行模式 中才能完成保存退出操作。当咱们在末行模式中键入:wq!时就意味着强制保存并退出文件，然后便可以用cat命令查看到保存文件后的信息了[root@localhost workdir]# cat practice.txtYou can write in it. 感觉是不是很简单，咱们接下来继续编辑这个文件，因为要在原有文本的内容下面追加内容，所以在命令模式中敲击o键的话会更高效呢.现在是不是感觉对vim编辑器有了一些实战经验呢，也不是想象中的那么难吧~现在咱们查看下文本的内容会发现果然后面一次输入的内容并没有被保存下来:[root@localhost workdir]# cat practice.txtYou can write in it. 配置主机名称为了便于在局域网中指定查找某个用户的电脑或区别主机的作用，除了要有IP地址外还要配置一个主机名，用户之间可以通过这个类似于域名的名称来便捷的相互访问。绝大部分的Linux系统主机名都是保存在/etc/hostname文件中的，咱们要想将其内容修改为”linuxprobe.com”，思路大致如下： 使用vim编辑器修改”/etc/hostname”主机名称文件。 把原始主机名称删除后追加”linuxprobe.com”。 保存退出文档并用hostname命令检查是否修改成功。 使用hostname命令查看当前的主机名称，但有时系统不能立即同步到主机名称已经发生改变，所以如果您确认修改完成却还显示原来的主机名称，可重启虚拟机后再查看下：[root@localhost workdir]# hostnamecaijy.com 配置网卡信息能够正确的配置网卡IP地址是保证两台服务器互相通信的前提，而Linux系统中的一切都是文件，配置网络的工作其实就是在编辑网卡配置文件，因此这个小任务不仅是帮助您熟练操作vim编辑器的过程，还是在为以后学习各种服务课程打下深深的基础。 在红帽RHEL7系统中的网卡配置文件前缀则以 “ifcfg-eno” 开始的,例如现在要想配置一个名称为eno16777736的网卡设备开机自启动并且IP地址、子网、网关等信息由人工指定的话思路应该是： 首先要切换到”/etc/sysconfig/network-scripts”目录中（该目录存放着网卡的配置文件）。 使用vim编辑器修改网卡文件”ifcfg-eno16777736”，逐项写入配置参数并保存退出，因每台电脑的硬件及架构情况都是不一样的，同学们的网卡默认名称请通过ifconfig命令自行确认。 设备类型:TYPE=Ethernet 地址分配模式:BOOTPROTO=static 网卡名称:NAME=eno16777736 是否启动:ONBOOT=yes IP地址:IPADDR=192.168.10.10 子网掩码:NETMASK=255.255.255.0 网关地址:GATEWAY=192.168.10.1 DNS地址:DNS1=192.168.10.1 重启网卡设备并测试网络是否联通。 进入到网卡配置文件所在的目录，然后编辑网卡配置文件填入下面的信息：执行重启网卡设备的命令，正常情况不会有提示信息，然后通过ping命令测试网络能否联通。[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ping 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.029 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.032 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.032 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.040 ms64 bytes from 192.168.10.10: icmp_seq=5 ttl=64 time=0.066 ms64 bytes from 192.168.10.10: icmp_seq=6 ttl=64 time=0.031 ms^C--- 192.168.10.10 ping statistics ---6 packets transmitted, 6 received, 0% packet loss, time 5002msrtt min/avg/max/mdev = 0.029/0.038/0.066/0.013 ms 配置Yum仓库前面了解过Yum软件仓库的作用是为了进一步简化RPM管理软件难度以及自动分析所需软件包及其依赖关系的技术。您可以把Yum想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而只需要说出所需的软件包名称，系统就会自动的为您搞定一切。那么既然要使用Yum技术，就要先把软件仓库搭建起来，然后将其配置规则确定好才行 首先要进入到”/etc/yum.repos.d/“目录中（因为该目录存放着yum仓库的配置文件） 使用vim编辑器创建一个名为rhel7.repo的新配置文件（文件名称可随意，但后缀必须为repo），逐项写入下面加粗的配置参数并保存退出（不写中文注释）。 [rhel-media] yum仓库唯一标识符，避免与其他仓库冲突。 name=linuxprobe yum仓库的名称描述，易于识别仓库用处。。 baseurl=file:///media/cdrom 提供方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..） enabled=1 设置此源是否可用，1为可用，0为禁用。 gpgcheck=1 设置此源是否校验文件，1为校验，0为不校验。 gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release 若为校验请指定公钥文件地址。 按配置参数的路径把光盘挂载，并把光盘挂载信息写入到/etc/fstab文件中。 使用”yum install httpd -y”命令检查Yum仓库是否已经可用。 进入到/etc/yum.repos.d目录中后创建Yum配置文件：[root@localhost network-scripts]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# vim rehl17.repo[rhel7]name=rhel7baseurl=file:///media/cdromenabled=1gpgcheck=0 创建挂载点后进行挂载操作，并设置成开机自动挂载[root@localhost yum.repos.d]# mkdir -p /media/cdrom[root@localhost yum.repos.d]# mount /dev/cdrom /media/cdrommount: /dev/sr0 is write-protected, mounting read-only[root@localhost yum.repos.d]# vim /etc/fstab/dev/cdrom /media/cdrom iso9660 defaults 0 0 尝试使用Yum软件仓库来安装Web服务，出现Complete（完成）则代表Yum仓库配置正确：[root@localhost yum.repos.d]# yum install httpdLoaded plugins: langpacks, product-id, subscription-managerThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.......Complete! 编写Shell脚本Shell终端解释器被形容是人与计算机硬件的“翻译官”，它作为用户与Linux系统内部通讯的媒介，除了允许了各种变量与参数外还提供了诸如循环、分支等高级语言才有的控制结构特性，如何正确的使用这些功能，准确下达命令尤为重要。Shell脚本的工作方式有两种，首先是前面所接触的交互方式(Interactive)，即当用户每输入一条命令就执行一次，而批处理(Batch)则是由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。因此在Shell脚本中不仅需要用到很多前面学习过的Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行加工，最终才能成为日常所见的Shell脚本程序，可以通过SHELL变量来查看到当前系统已经默认使用bash解释器作为命令行终端了：[root@localhost Desktop]# echo $SHELL/bin/bash 编写简单的脚本估计读者看完上面对Shell脚本如此复杂的描述都有一种心累想放弃的感觉了吧，但这仅指的是一个高深Shell脚本的编写原则，其实使用vim编辑器把linux命令按照顺序依次写入文件就是编写完成一个最简单的脚本啦。例如想查看当前所在工作路径并列出当前目录下所有文件及属性信息，编写一个脚本来完成的话是这样：[root@localhost Desktop]# vim example.sh#! /bin/bash#For Examplepwdls -alShell脚本文件的名称是可以任意起，但咱们应该遵守运维行业人员大众的规范把.sh后缀写上，这样让其他人一看就知道是个脚本文件，与人方便自己方便。在这个脚本中实际上出现了三种不同的元素，第一行脚本声明(#!)是用来告知系统用何种shell解释器来执行本脚本程序，第二行注释信息(#)是对程序功能和某些命令的介绍信息，使得自己或他人再次看到这个脚本内容时可以快速知道这些功能的作用或一些警告信息，第三、四行可执行语句也就是咱们平时执行的Linux命令啦~什么？同学们不相信这么简单就编写出来了一个脚本程序，那来执行看一看吧：[root@localhost Desktop]# bash example.sh/home/caijy/Desktoptotal 4848drwxr-xr-x. 4 caijy caijy 93 Sep 14 16:29 .drwx------. 14 caijy caijy 4096 Sep 14 11:05 ..drwxrwxr-x. 3 caijy caijy 20 Sep 14 12:34 c-rw-rw-r--. 1 caijy caijy 4946304 Sep 13 20:29 etc.tar.gz-rw-r--r--. 1 root root 38 Sep 14 16:28 example.sh-rw-rw-r--. 1 caijy caijy 0 Sep 13 20:21 linux.logdrwxrwxr-x. 2 caijy caijy 4096 Sep 13 21:06 mydir-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt第二种运行脚本程序的方法是以输入完整路径的方式来执行，但默认会因为权限不足而提示报错信息，这种情况只需要为脚本文件增加执行权限即可:[root@localhost Desktop]# ./example.shbash: ./example.sh: Permission denied[root@localhost Desktop]# chmod u+x example.sh[root@localhost Desktop]# bash example.sh/home/caijy/Desktoptotal 4848drwxr-xr-x. 4 caijy caijy 93 Sep 14 16:29 .drwx------. 14 caijy caijy 4096 Sep 14 11:05 ..drwxrwxr-x. 3 caijy caijy 20 Sep 14 12:34 c-rw-rw-r--. 1 caijy caijy 4946304 Sep 13 20:29 etc.tar.gz-rw-r--r--. 1 root root 38 Sep 14 16:28 example.sh-rw-rw-r--. 1 caijy caijy 0 Sep 13 20:21 linux.logdrwxrwxr-x. 2 caijy caijy 4096 Sep 13 21:06 mydir-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt 接收用户的参数但是像上面这样的脚本程序在功能上真的太过于“死板”，为了能够让Shell脚本程序更好的满足用户对灵活完成工作的热切需要，必须要让脚本程序能够像咱们以前执行命令时那样来接收用户输入进来的参数。 其实Shell脚本早就考虑到了这些，已经在脚本中定义好了很多变量功能，例如$0对应当前Shell脚本程序的名称，$#对应总共有几个参数，$*对应所有位置的参数值，而$1,$2,$3……依次类推则分别对应着第N个位置的参数:尝试来编写一个测试用的脚本程序，通过引用上面的变量参数来看下真实效果：[root@localhost Desktop]# vim example.sh#! /bin/bashecho &quot;当前脚本名称为$0.&quot;echo &quot;总共有$#个参数，分别是$*.&quot;echo &quot;第1个参数为$1,第5个为$5.&quot;[root@localhost Desktop]# bash example.sh one two three four five当前脚本名称为example.sh.总共有5个参数，分别是one two three four five.第1个参数为one,第5个为five. 判断用户的参数学习就像是在登台阶，在您学习完执行linux命令，掌握脚本语法变量和接收用户输入信息等方法后就要踏上新的高度——即能够进一步去处理接收到的用户的参数。因为有时咱们也需要像前面学习过的mkdir命令一样来判断用户输入的信息，从而判断用户指定的文件夹名称是否已经存在，已存在则提示报错，不存在则自动的创建。条件测试语法能够判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。 条件判断语句按照测试对象可分为 文件测试、逻辑测试、整数值比较与字符串比较，文件测试即用来按照指定条件来判断文件是否存在或权限是否满足，具体的参数包括有： 操作符 作用 -d 测试是否为目录 -e 测试文件或目录是否存在 -f 判断是否为文件 -r 测试当前用户是否有权限读取 -w 测试当前用户是否有权限写入 -x 测试当前用户是否有权限执行 好啦，那么先通过文件测试语句来判断/etc/fstab是否为一个目录文件，然后通过$?变量来显示上一条命令执行后的返回值，这样就可以通过返回的非零值判断目录是不存在的了（即文件测试语句判断结果不符合）：[root@localhost Desktop]# [ -d /etc/fstab ][root@localhost Desktop]# echo $?1再来用文件测试语句来判断下/etc/fstab是否为一般文件，这样看到返回值是0即代表这个一般文件是存在的：[root@localhost Desktop]# [ -f /etc/fstab ][root@localhost Desktop]# echo $?0逻辑测试则是用于判断用户给出的条件是为真还是假，从而把条件测试语句与逻辑语句相搭配结合使用可以实现一个更高级的使用方法，例如在Shell终端中逻辑“与”符号是&amp;&amp;，它代表当前面的命令执行成功后才会执行后面的命令，因此可以用来判断/dev/cdrom设备是否存在，若存在时才输出Exist字样。[root@localhost Desktop]# [ -e /dev/cdrom ] &amp;&amp; echo &quot;exist&quot;exist除了“与”逻辑测试符号外,还有逻辑“或”，“非”符号，在Linux系统中逻辑“非”的符号就是一个叹号，它代表把条件测试中的判断结果取相反值。 整数比较运算符是仅对数字的测试操作，不能把数字与字符串、文件等内容一起操作，而且不能想当然的使用日常生活中的等号、大于号、小于号等来做判断，因为等号与是赋值命令符冲突，大于号和小于号分别是和输出重定向命令符和输入重定向命令符冲突。虽然有时候碰巧也能执行成功，但是在后面脚本程序中普遍会产生错误，一定要使用规范的整数比较运算符来进行操作： 操作符 作用 -eq 判断是否等于 -ne 判断是否不等于 -gt 判断是否大于 -lt 判断是否小于 -le 判断是否等于或小于 -ge 判断是否大于或等于 咱们先小试牛刀的测试下10是否大于10以及10是否等于10，依次通过判断输出的返回值内容来进行判断：[root@caijy Desktop]# [ 10 -gt 10 ][root@caijy Desktop]# echo $?1[root@caijy Desktop]# [ 10 -eq 10 ][root@caijy Desktop]# echo $?0在前面第2章的第四小节中学习过一个叫做free的命令，它能够获取到当前系统正在使用及可用的内存量信息。接下来咱们先用free -m命令查看以兆为单位的内存使用量情况，然后通过grep Mem:命令对关键词匹配过滤出剩余内存量的行，再用awk ‘{print $4}’命令过滤只保留第三列，最后用FreeMem=`语句`的方式把语句内执行的结果赋值给变量，这个演示确实有些难度，但看懂后会觉得很有意思，写到笔记本上在运维工作时也会用得上。[root@caijy Desktop]# free -mtotal used free shared buffers cachedMem: 1826 867 959 9 0 278-/+ buffers/cache: 588 1238Swap: 2047 0 2047[root@caijy Desktop]# free -m | grep -n Mem2:Mem: 1826 867 959 9 0 278[root@caijy Desktop]# free -m | grep -n Mem | awk &#39;{print $4}&#39;955[root@caijy Desktop]# FreeMem=`free -m | grep Mem | awk &#39;{print $4}&#39;[root@caijy Desktop]# echo $FreeMem953上面做的获取内存可用量的步骤有些难度“超纲”了，如果不能够马上理解也不用担心，接下来才是重点，需要通过整数运算符来判断内存可用量的值是否小于1024，若小于则会提示内存不足的字样：[root@caijy Desktop]# [ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot;Insufficient Memory字符串比较是判断测试字符串是否为空值，或两个字符串是否相同的操作，常常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单，常见的操作运算符如下： 操作符 作用 = 比较字符串内容是否相同。 != 比较字符串内容是否不同。 -z 判断字符串内容是否为空。 咱们可以通过判断String变量是否为空值，进而判断是否未被定义：[root@caijy Desktop]# [ -z $String ][root@caijy Desktop]# echo $?0最后再尝试把逻辑运算符引入来试试，当判断用于保存当前语系的环境变量值LANG不是为英语（en.US）则会满足逻辑条件并输出非英语的字样：[root@caijy Desktop]# echo $LANGen_US.utf8[root@caijy Desktop]# [ $LANG != &quot;en.US.utf8&quot; ] &amp;&amp; echo &quot;Not en.US.utf8&quot;Not en.US.utf8 流程控制语句接下来咱们通过if、for、while、case四种条件、循环语句来学习相对更高难度级别的Shell脚本. if条件测试语句if条件语句可以让脚本根据实际情况的不同而自动切换命令执行方案，从技术角度上来说分为单分支结构、双分支结构、多分支结构，复杂度随着灵活度一起逐级上升。 单分支的if条件语句结构，这种结构仅用if、then、fi关键词组成，只在条件成立后才执行预设命令，相当于口语的“如果……那么……”，属于最简单的一种条件判断结构，操作语法如图4-17所示：使用单分支的if条件语句来判断某个目录是否存在，若已经存在就结束条件判断和整个Shell脚本，而如果不存在则去创建这个目录：[root@caijy Desktop]# vim mkcdrom.sh#! /bin/bashDIR=&quot;/media/cdrom&quot;if [ ! -e $DIR ]thenmkdir -p $DIRfi 双分支的if条件语句结构，这种结构仅用if、then、else、fi关键词组成，进行两次条件判断匹配，两次判断中任何一项匹配成功后都会执行预设命令，相当于口语的“如果……那么……或者……那么……”，也是属于很简单的一种条件判断结构，操作语法如图4-18所示： 使用双分支的if条件语句来验证某个主机是否在线，然后根据判断执行返回值结果分别给予对方主机是在线还是不在线的提示信息。脚本中我主要是使用ping命令来测试与对方主机的网络联通性，而linux系统中的ping命令不像windows系统一样仅会尝试四次就结束，因此为了避免用户等待时间过长，而通过-c参数来规定尝试的次数，-i参数定义每个数据包的发送间隔时间以及-W参数定义最长的等待超时时间。[root@caijy Desktop]# vim chkhost.sh#! /bin/bashping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/nullif [ $? -eq 0 ]thenecho &quot;Host $1 is On-line.&quot;elseecho &quot;Host $1 is Off-line.&quot;fi192.168.10.10是服务器本机地址，验证下脚本的效果吧：[root@caijy Desktop]# bash chkhost.sh 192.168.10.10Host 192.168.10.10 is On-line.[root@caijy Desktop]# bash chkhost.sh 192.168.10.20Host 192.168.10.20 is Off-line.多分支的if条件语句结构，这种结构需要使用if、then、else、elif、fi关键词组成，进行多次条件判断匹配，多次判断中任何一项匹配成功后都会执行预设命令，相当于口语的“如果……那么……如果……那么……N次等等”，这是一种工作中最常使用的条件判断结构，虽然相对复杂但更加灵活，操作语法如图4-19所示：使用多分支的if条件语句来判断用户输入的分数在那个成绩区间内，然后输出如优秀、合格、不合格等提示信息。read是用来读取用户输入信息的命令，它能够把接收到的用户输入信息赋值给后面的指定变量，而-p参数则是给予了用户一定的提示信息。下面实例中判断用户输入的分数是否同时具备大于等于85分且小于等于100分，这样的话才输出Excellent字样，若上一条件没有匹配成功则继续判断用户输入分数是否大于等于70分且小于等于84分，这样的话输出Pass字样，如果两次都落空没有匹配成功，则最终输出Fail字样：[root@caijy Desktop]# vim chkscore.sh#!/bin/bashread -p &quot;Enter your score(0-100): &quot; GRADEif [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ]then echo &quot;$GRADE is Excellent&quot;elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ]then echo &quot;$GRADE is Pass&quot;elseecho &quot;$GRADE is Fail&quot;fi[root@caijy Desktop]# bash chkscore.shEnter your score(0-100): 8989 is Excellent[root@caijy Desktop]# bash chkscore.shEnter your score(0-100): 7575 is Pass[root@caijy Desktop]# bash chkscore.shEnter your score(0-100): 5656 is Fail for条件循环语句for循环语句可以让脚本一次性读取多个信息值，然后逐一对信息值进行循环操作处理，因此当您要处理的数据是有目标和范围时简直再适合不过了~例如使用for循环语句来从列表文件中读取多个用户名，然后逐一创建用户帐号并为其设置密码。[root@caijy Desktop]# vim users.txtandybarrycarldukeericgeorgeShell脚本中使用read命令来读取用户输入的密码值后赋值给PASSWD变量，并通过-p参数来显示一段给用户的提示内容，告诉用户正在输入的内容即将作为帐号密码。当下面的脚本执行后会自动的用users.txt列表文件中获取到所有的用户名称值，然后逐一使用id 用户名的方式查看用户的信息，并使用$?变量判断这条命令是否执行成功，也就是判断该用户是否已经存在。而/dev/null是被称作Linux的黑洞的文件，把输出信息重定向到这个文件后等同于删除数据（没有回收功能的垃圾箱），让用户的屏幕窗口保持简洁。[root@caijy Desktop]# vim Example.sh#!/bin/bashread -p &quot;Enter The Users Password :&quot; PASSWD`for UNAME incat users.txt`` do`id $UNAME &amp;&gt; /dev/nullif [ $? -eq 0 ]thenecho &quot;Already exists&quot;elseuseradd $UNAME &amp;&gt; /dev/nullecho &quot;$PASSWD&quot; | passwd --stdin $UNAME &amp;&gt; /dev/nullif [ $? -eq 0 ]thenecho &quot;$UNAME, Create success&quot;elseecho &quot;$UNAME, Create failure&quot;fifidone[root@caijy Desktop]# bash Example.shEnter The Users Password :123456andy, Create successbarry, Create successcarl, Create successduke, Create successeric, Create successgeorge, Create success[root@caijy Desktop]# tail -6 /etc/passwdandy:x:1001:1001::/home/andy:/bin/bashbarry:x:1002:1002::/home/barry:/bin/bashcarl:x:1003:1003::/home/carl:/bin/bashduke:x:1004:1004::/home/duke:/bin/basheric:x:1005:1005::/home/eric:/bin/bashgeorge:x:1006:1006::/home/george:/bin/bash while条件循环语句这是一种让脚本根据某些条件来重复执行命令的条件循环语句，而这种循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目的、有范围的使用场景。而while循环语句判断是否继续执行命令的依据一般是检查若条件为真就继续执行，而条件为假就结束循环，循环结构如图4-21所示：接下来就来利用多重分支的if条件测试语句与while条件循环语句来结合写一个用来判断数值的脚本吧，脚本中会使用$RANDOM变量来调取出一个随机的数值（范围:0–32767），然后通过expr命令计算取整出1000以内的一个随机数值，用这个数值来跟用户通过read命令输入的数值做比较判断。判断语句结构分为三项，分别是判断是否相等、是否大于随机值以及是否小于随机值，但这不是重点~关键是在于while条件循环语句的判断值为true，因此会无限的运行下去，直到猜中后运行exit 0命令才终止脚本。[root@caijy Desktop]# vim Guess.sh#!/bin/bashPRICE=$(expr $RANDOM % 1000)TIMES=0echo &quot;商品实际价格为0-999之间，猜猜看是多少？&quot;while truedoread -p &quot;请输入您猜测的价格数目：&quot; INTlet TIMES++if [ $INT -eq $PRICE ]thenecho &quot;恭喜您答对了，实际价格是 $PRICE&quot;echo &quot;您总共猜测了 $TIMES 次&quot;exit 0elif [ $INT -gt $PRICE ]thenecho &quot;太高了！&quot;elseecho &quot;太低了！&quot;fidone[root@caijy Desktop]# bash Guess.sh商品实际价格为0-999之间，猜猜看是多少？请输入您猜测的价格数目：500太低了！请输入您猜测的价格数目：750太低了！请输入您猜测的价格数目：850太低了！请输入您猜测的价格数目：920太高了！请输入您猜测的价格数目：880太高了！请输入您猜测的价格数目：865太低了！请输入您猜测的价格数目：870太低了！请输入您猜测的价格数目：875太高了！请输入您猜测的价格数目：873恭喜您答对了，实际价格是 873您总共猜测了 9 次 case条件测试语句如果您学习过C语言，此刻一定是会心一笑，这不就是switch语句吗？是的，功能非常相似！case条件测试语句是在多个范围内匹配数据，若匹配到则执行相关命令并结束整个条件测试，而如果数据不在所列出的范围内，则会去执行)中所规定的默认命令，测试结构如图4-22所示：刚刚学习的脚本普遍有一个致命的弱点，不信您就输入一个字母或乱码试一试~脚本立即就崩溃了。这是由于字母是不能跟数字做大小比较的，例如a是否大于等于3，这样的命题完全错误，变量操作会直接导致系统崩溃。咱们必须马上想出一个办法来判断用户的输入内容，一旦碰到字母或乱码也能予以提示，不至于因错误输入而崩溃，因此这样的需求用case条件测试语句和第3章节中学习的通配符来一起组合写一个脚本简直再适合不过了~提示用户输入一个字符并将其赋值给变量KEY，判断变量KEY为何种字符后分别输出是字母、数字还是其他字符：[root@caijy Desktop]# vim CheckKeys.sh#!/bin/bashread -p &quot;请输入一个字符，并按Enter键确认：&quot; KEYcase &quot;$KEY&quot; in[a-z]|[A-Z])echo &quot;您输入的是 字母。&quot;;;[0-9])echo &quot;您输入的是 数字。&quot;;;`)`echo &quot;您输入的是 空格、功能键或其他控制字符。&quot;esac[root@caijy Desktop]# bash CheckKeys.sh请输入一个字符，并按Enter键确认：w您输入的是 字母。[root@caijy Desktop]# bash CheckKeys.sh请输入一个字符，并按Enter键确认：1您输入的是 数字。[root@caijy Desktop]# bash CheckKeys.sh请输入一个字符，并按Enter键确认：` 您输入的是 空格、功能键或其他控制字符。 计划任务服务程序厉害的系统运维工程师能够让Linux系统实现自动化工作，无需人工的干预就可以让各个服务、命令在指定的时间段执行、服务或停止。更何况咱们已经有了如此彪悍的脚本程序，如果只是需要每天凌晨两点敲一下回车去执行这个Shell脚本程序，这样的工作简直就是痛苦死了（或者训练您家的小猫半夜按下回车键）。接下来学习如何来设置服务器的计划任务服务，把有周期规律性的工作交给系统去自动完成。计划任务有“一次性”与“长期性”的区分，可以理解为： 一次性计划任务:今晚11点30分开启网站服务（例如新网站的公测） 长期性计划任务:每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz 一次性计划任务顾名思义就只是一次性有效，一般用于临时的工作需要，咱们可以用at命令实现这种功能，只需要写成”at 时间”的形式就可以，如果想要查看已设置好但还未执行的计划任务可以用”at -l”命令，而删除的话可以用”atrm 任务序号”即可，默认用at命令来设置计划任务的话是通过交互式的方法，例如设置系统在今晚23:30分自动重启网站服务吧：[root@caijy Desktop]# at 20.30at&gt; systemctl restart httpdat&gt; &lt;EOT&gt; --注：此处请同时按下Ctrl+d来结束编写计划任务job 1 at Thu Sep 14 20:30:00 2017[root@caijy Desktop]# al -lbash: al: command not found...[root@caijy Desktop]# at -l1 Thu Sep 14 20:30:00 2017 a root当然如果您想挑战一下更加高难度但又简便的方式，可以把前面章节中学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划任务，这样的话在Shell脚本中都可以做引用了~[root@caijy Desktop]# echo &quot;systemctl restart httpd&quot; | at 21.00job 2 at Thu Sep 14 21:00:00 2017[root@caijy Desktop]# at -l1 Thu Sep 14 20:30:00 2017 a root2 Thu Sep 14 21:00:00 2017 a root如果一不不小心设置了两条，想要删除其中一条的话也是很简单的：[root@caijy Desktop]# atrm 1[root@caijy Desktop]# at -l2 Thu Sep 14 21:00:00 2017 a root而如果您的工作需要是有周期规律性的，那Linux系统中默认启用的crond服务简直再适合不过了，创建、编辑计划任务的命令为”crontab -e”，查看当前计划任务的命令为”crontab -l”，删除某条计划任务的命令为”crontab -r”，另外如果您登录的是超级用户的话，还可以通过加上-u参数来编辑其他人的计划任务。不过在正式的部署计划任务前，请念一下口诀“分、时、日、月、星期 命令”，这是使用crond服务设置任务的参数格式，没有设置的位置也要用*号占位： 字段 说明 分钟 取值为从0到59之间的整数 小时 取值为从0到23之间的任意整数 日期 取值为1到31之间的任意整数 月份 取值为1到12之间的任意整数 星期 取值为0到7之间的任意整数，其中0与7均为星期日 命令 要执行的命令或程序脚本 参考上面crond计划任务实现的参数格式，假设目前每周一、三、五的凌晨3点25分都需要把某个网站数据目录通过tar命令打包成一个压缩包来当做备份文件，那么除了用减号(-)来表示一段连续的时间周期，例如12-15就可以代表每月的12-15日，除号（/）代表任务的间隔时间，例如/2就是每隔2分钟执行一次的意思，还可以用逗号（,）来分别表示多个时间段，如8,9,12来代表八月、九月和12月执行任务，那么来尝试做一下吧：[root@caijy Desktop]# crontab -eno crontab for root - using an empty onecrontab: installing new crontab[root@caijy Desktop]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot而如果计算机服务器中需要有多条计划任务，并且这次的工作是每周一至五的每天的凌晨1点钟清空/tmp临时目录中的所有文件，就可以把相应的参数依次写到下面。而在crond服务的计划任务参数中所有的命令请一定要用绝对路径的方式来写，如果不知道的话用whereis命令来查下吧：[root@caijy Desktop]# whereis rmrm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz[root@caijy Desktop]# crontab -ecrontab: installing new crontab[root@caijy Desktop]# crontab -l25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot0 1 * * 1-5 /usr/bin/rm -rf /tmp/*对同学们今后工作中使用计划服务来嘱咐几句建议，首先是crond服务的配置参数中可以像Shell脚本一样以#号开头来写上注释信息，这样方便以后再看到这段命令代码时快速回忆起功能、需求以及当时编写人等等重要信息，其次是计划任务中的分钟项目必须有数值，绝对不能为空或是*号，而日和周不能同时使用，否则就会发生冲突，这些细节我想您一定要记下。 转载自：http://www.linuxprobe.com/chapter-04.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程03]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F14%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B03%2F</url>
    <content type="text"><![CDATA[我们已经学习了数十个常用的Linux系统命令，以后要把这些命令通过语法结合使用。这里学习Linux命令与文件读写操作有关的重定向技术的五种模式——标准覆盖输出重定向、标准追加输出重定向、错误覆盖输出重定向、错误追加输出重定向、输入重定向。 输入输出重定向简单用一句话来概括即 “使用输入重定向能够把文件导入到命令中，而输出重定向则是能够把原本要输出到屏幕的数据信息写入到指定文件中”。平常输出重定向会使用得多一些，细分之下又有 标准输出重定向 和 错误输出重定向 两种技术以及 清空写入 和 追加写入 两种模式。 标准输入(STDIN，文件描述符为0)：默认从键盘输入，为0时表示是从其他文件或命令的输入。 标准输出(STDOUT，文件描述符为1)：默认输出到屏幕，为1时表示是文件。 错误输出(STDERR，文件描述符为2)：默认输出到屏幕，为2时表示是文件。 对于输入重定向有这些情况： 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见“分界符”才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 对于输出重定向有这些情况： 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt; &amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 试一下吧，通过标准输出重定向将“man bash”命令原本要输出到屏幕的信息写入到文件中去，效果类似于： 有没有感觉到特别方便呢？那么接下来试试输出重定向技术中的 清空写入 与 追加写入 两种不同模式带来的变化吧~先通过清空模式向文件写入一行数据（该文件中包含上一个实验的man命令信息），然后再通过追加模式向文件再写入一次数据，最终咱们看到的文件内容会是这个样子的：[caijy@localhost Desktop]$ echo &quot;Welcome to linux&quot; &gt; readme.txt[caijy@localhost Desktop]$ echo &quot;Quality linux learning materials&quot; &gt;&gt; readme.txt[caijy@localhost Desktop]$ cat readme.txtWelcome to linuxQuality linux learning materials 虽然都是输出重定向技术，但对于不同命令的标准输出和错误输出还都有点区别，例如查看下当前目录中某个文件的信息吧。因为这个文件是真实存在的，因此使用标准输出即可将数据写入到文件中，而错误的输出重定向则不行，依然会把信息输出到了屏幕上。[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l readme.txt &gt; out.txt[caijy@localhost Desktop]$ cat out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt[caijy@localhost Desktop]$ ls -l readme.txt 2&gt; out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt 那如果是想把命令的报错信息写入到文件呢？例如当您在执行一个自动化的Shell脚本时会特别的实用，因为可以通过把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来学习实践中咱们就以一个不存在的文件做演示吧：[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l xxxls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx &gt; out.txtls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx 2&gt; out.txt[caijy@localhost Desktop]$ cat out.txtls: cannot access xxx: No such file or directory 输入重定向作用是把文件直接导入到命令中。接下来使用输入重定向把文件导入给“wc -l”命令来统计下内容行数吧，这样命令其实等同于接下来要学习的“cat readme.txt | wc-l”的管道符命令组合。[caijy@localhost Desktop]$ wc -l &lt; readme.txt2 管道命令符管道符的输入方法是同时按下键盘的“Shift”与“\”键，执行格式为“命令A | 命令B”，其实管道命令符的作用也能用一句话来概括： “把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入” 。回想前面学习过的grep文本搜索命令通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户，其实只要学完了这个小节，完全可以把下面的两条命令合并到一起。[caijy@localhost Desktop]$ grep &quot;/sbin/nologin&quot; /etc/passwd | wc -l33 学习到了这个管道符就像拿到了一个法宝，让咱们来套用到其他不同的命令上吧，比如用翻页的形式查看/etc目录中的文件列表及属性信息吧（默认会一股脑的都显示到屏幕上，根本看不清楚）： [root@localhost Desktop]# echo &quot;linux&quot; | passwd --stdin rootChanging password for user root.passwd: all authentication tokens updated successfully. 对于这个管道符命令是不是觉得有些相见恨晚？其实玩法还有很多，比如默认发送邮件需要交互式的进行才行，而此时则可以通过一条结合了管道符的命令语句把编辑好的内容与标题一起的“打包”，最终用一条命令就顺利的给用户发送了邮件。[root@localhost Desktop]# echo &quot;Context&quot; | mail -s &quot;Subject&quot; caijy[root@localhost Desktop]# su caijy[caijy@localhost Desktop]$ mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/caijy&quot;: 1 message 1 new&gt;N 1 root Thu Sep 14 11:01 18/612 &quot;Subject&quot; 能不能让这样方便的命令写的更高级一些呢？下面这条自造命令就是通过把mail邮件命令与输入重定向的分界符来结合使用，效果是让用户可以一直的输入内容，直到系统遇到匹配上了用户定义的分界符才最终结束。[root@localhost Desktop]# mail -s &quot;Readme&quot; root@localhost.localdomain &lt;&lt; over&gt; I think linux is very practical&gt; I hope to learn more&gt; can you teach me ?&gt; over 当然大家可不要误解管道命令符只能用一次哦，完全可以这样用：“命令A|命令B|命令C”。 命令行的通配符例如想批量查看所有硬盘文件的相关权限属性，笨笨的命令会是这样的：[root@localhost Desktop]# ls -l /dev/sdabrw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sda[root@localhost Desktop]# ls -l /dev/sda1brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1[root@localhost Desktop]# ls -l /dev/sda2brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda3ls: cannot access /dev/sda3: No such file or directory幸亏我的硬盘文件和分区只有3个，要是有几百个的话，估计一天的工作时间都要忙活这个事了。咱们此时已经能看出一些简单规律了，比如这些硬盘设备文件共性都是以sda开头并且存放到了/dev目录中，那即便不知道分区编号和具体分区的个数也一样可以用通配符来搞定。通配符顾名思义就是通用的匹配信息的符号，比如星号(*)就是代表匹配零个或多个字符，问号(?)是代表匹配单个字符，中括号内加上数字[0-9]代表匹配单个阿拉伯数字的字符，而中括号内加上字母[abc]则是代表匹配单个指定的英文字母。[root@localhost Desktop]# ls -l /dev/sda*brw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sdabrw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2如果只需要看sda后面一定要有个字符的文件相关信息呢？那就要用到问号来通配了。[root@localhost Desktop]# ls -l /dev/sda?brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2您除了可以用[0-9]来通配所有的单个阿拉伯数字，也可以用[135]这样的方式仅匹配这三个指定数字，若没有通配到即不会显示出来：[root@localhost Desktop]# ls -l /dev/sda[0-9]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda[135]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1 常用的转义字符Shell解释器为了能够更好的理解您想表达的意思，还提供了特别丰富的转义符号来帮助程序员处理输入的特殊数据。常见的转义字符包括有：反斜杠()的作用就是转义后面的一个变量变为单纯的字符串，单引号(‘’)则是转义其中所有的变量为单纯的字符串，而双引号（””）是保留其中的变量属性不转义，反引号(``)则是把其中的命令执行后返回一个结果。例如咱们先定义一个名称为PRICE的变量并赋值为5，然后通过双引号括起来输出字符串与变量结合的结果：[root@localhost Desktop]# PRICE=5[root@localhost Desktop]# echo &quot;Price is $PRICE&quot;Price is 5[root@localhost Desktop]# echo &quot;Price is $$PRICE&quot;Price is 44837PRICE原本刚刚是希望能够进一步输出“Price is $5”即价格是五美元的字符串信息，但碰巧美元符号与变量提取符号冲突了，因此输出的并不是预想的信息。需要用转义符把第一个$符号转换成单纯的字符串，再或者把整段都转义成单纯的字符串吧（当然这个只是让您看下效果，并不符合实验需要）：[root@localhost Desktop]# echo &quot;Price is \$$PRICE&quot;Price is $5[root@localhost Desktop]# echo &#39;Price is \$$PRICE&#39;Price is \$$PRICE 最后一个您可能看到结果时会觉得很无用，因此暂且先不用管具体的使用场景，就当作是提前为SHELL编程知识学习做一点小小的铺垫吧。如果只需要某个命令的返回输出值时，就可以用像 命令 这样用反引号括起来的命令格式来达到效果，例如通过反引号与uname -a命令结合通过返回值来查看下本机版本和内核信息吧：[root@localhost Desktop]# echo `uname -a` Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux 重要的环境变量变量是计算机系统中用于保存可变值的数据类型，在Linux系统中一般变量名称都是大写的，这仅算是一种约定俗成的规范，平时可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来指定系统运行环境的一些参数，比如每个用户不同的家目录、邮件保存存放位置等等。 前面小节中提到的一个概念——即Linux系统中一切都是文件，因此Linux命令肯定也不例外，那当用户执行了一条命令之后到底发生了什么事情呢？简单来说就是四个步骤： 第1步骤阶段是判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。 第2步骤阶段是检查用户输入的命令是否为“别名命令”，即用一个自创的命令名称来替换原本的命令名称。可以用alias命令来创建一个属于自己的命令别名，格式为: alias 新的命令=’原命令 -选项/参数’，若要取消一个别名的话则是用unalias命令，格式为：“unalias 别名”。例如以前每次用rm命令删除文件的时候都要被要求再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，咱们可以把它取消掉：[root@localhost Desktop]# alias rmalias rm=&#39;rm -i&#39;[root@localhost Desktop]# unalias rm[root@localhost Desktop]# rm out.txt 第3步骤阶段就是由Bash解释器来判断用户输入的是个内部命令还是个外部命令，内部命令是解释器内部的指令，会被直接的执行，而绝大部分的时候都会是外部命令，交由给第4步骤来继续处理，您可以使用“type 命令名称”来手工判断是内部命令还是外部命令，也是很有趣的。 第4步骤阶段是系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫做PATH，可以简单把它理解成是“解释器的小助手”，作用是告诉Bash解释器要执行的命令可能存放到了那里，然后Bash解释器就会乖乖的在这些目录中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，咱们对PATH变量内这些路径的增加和删除操作将会直接影响bash解释器搜索linux命令的位置。[root@localhost Desktop]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin[root@localhost Desktop]# echo PATH=$PATH:/root/binPATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin:/root/bin 这里有比较经典的问题：“为什么不能在$PATH中添加进当前目录(.)?”答案：虽然把$PATH变量添加了当前目录(.)会在一些情况让用户免去输入命令所在路径的麻烦，但如果黑客在比较常用的公共目录/tmp中存放了一个名为”ls”或”cd”的同名木马文件，那么用户就极有可能错误的执行了。作为一名态度谨慎、有经验的运维人员在接手了一台Linux系统后一定会在执行命令前先检查下PATH变量中是否有可疑的目录，另外读者们从PATH变量的例子中是不是也感觉到环境变量特别实用呢~您可以使用env命令来查看到linux系统中所有的环境变量，在此摘录最重要的10个环境变量： 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的SHELL解释器名称。 HISTSIZE 定义了 history 命令输出的记录数 HISTFILESIZE 定义了在文件 ~/.bash_history 中保存命令的记录总数 MAIL 邮件信箱文件保存路径。 LANG 系统语言、语系名称。 RANDOM 生成一个随机数字。 PS1 bash解释器的提示符。 PATH 定义解释器搜索用户执行命令的路径。 EDITOR 用户默认的文本编辑器。 Linux系统为了能够为每个用户提供独立的、合适的工作运行环境，因此在不同的用户身份下提取一个相同的变量也可能会获得不同的值，例如查看下HOME变量在不同用户身份下的值都有那些吧（su是用于切换用户身份的命令）：[root@localhost Desktop]# echo $HOME/root[root@localhost Desktop]# su - caijyLast login: Thu Sep 14 11:01:16 CST 2017 on pts/0[caijy@localhost ~]$ echo $HOME/home/caijy 其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，如果工作需要完全可以自己手工创建的，例如设置一个名称为WORKDIR的变量，方便用户更轻松的进入一个很深层的目录：[caijy@localhost Desktop]$ mkdir -p c/workdir[caijy@localhost Desktop]$ WORKDIR=c/workdir[caijy@localhost Desktop]$ cd $WORKDIR[caijy@localhost workdir]$ pwd/home/caijy/Desktop/c/workdir 但是这样的变量不具有全局性，作用范围也是有限的，默认不能够被其他用户使用的，如果工作需要的话咱们可以使用export命令将其提升为全局变量，这样其他的用户也就可以使用到这个变量了。 转载自：http://www.linuxprobe.com/chapter-03.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程02]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B02%2F</url>
    <content type="text"><![CDATA[新手必须掌握的Linux命令 shell简介通常计算机硬件是由运算器、控制器、存储器、输入/输出设备等等这些物理设备共同组成的，而能够让机箱内各种硬件设备各司其职的东西就叫做系统内核。Linux系统的内核负责驱动硬件、管理活动和分配/管理硬件资源等等任务，如此说来系统内核对计算机正常稳定的运行来讲可真的是太重要了，因此一般不建议直接去编辑内核中的参数，而是让用户通过基于“系统调用接口”开发出的程序/服务来管理计算机，这样一层层环环相扣来满足咱们的日常工作需要.“Shell”——也可称为“壳”，充当的是人与内核（硬件）的翻译官，用户把一些命令“告诉”Shell终端，它就会调用相应的程序服务执行工作啦主流Linux系统选择Bash解释器作为命令行终端主要有以下4项优势: 通过上下方向键来调取过往执行过的Linux命令。 命令或参数仅需输入前几位就可以用tab键补全。 强大的批处理脚本。 实用的环境变量。 man–帮助命令常见执行Linux命令的格式是这样的(中间有空格)： 命令名称 [命令参数] [命令对象] 命令对象一般是指要被处理的文件、目录、用户等资源，而命令参数可以选用长格式（完整的选项名称）也可选用短格式（单个字母的缩写），一般分别用”–”与”-“做前缀。 长格式如:man –help短格式如:man -h 进入Linux，打开terminal,输入：man man,便可看到man命令自身的帮助信息： 进入man命令帮助信息界面后的常用操作按键包括有（与后面章节中学习的vim编辑器非常相像）: 按键 用处 空格键 向下翻一页 Page Down 向下翻一页 Page Up 向上翻一页 HOME 去往首页 END 去往尾页 /关键词 从上至下搜索“关键词” ？关键词 从下至上搜索“关键词” n 定位到下一个关键词 N 定位到上一个关键词 q 退出帮助文档 一般帮助文档都很长，我们应该了解它们的结构来更好得获得帮助 结构名称 代表意义 NAME 命令的名称 SYNOPSIS 参数的大致用法 DESCRIPTION 介绍说明 EXAMPLES 举例说明 OVERVIEW 概述 DEFAULTS 默认的功能 OPTIONS 可用的选项 ENVIRONMENT 环境变量 FILES 用到的文件 SEE ALSO 相关的资料 HISTORY 维护历史 常用系统工作命令echo命令用于在终端显示字符串或输出变量提取后的值，格式为：“echo [字符串 | $变量]”。把指定字符串输出到终端屏幕：使用$变量的方式提取变量值并输出到屏幕： date命令用于显示及设置系统的时间或日期，格式为：”date [选项] [+指定的格式]”。date命令参数常见的格式如下： 参数 作用 %t 跳格（tab键） %H 小时（00-23） %I 小时（00-12） %M 分钟（00-59） %S 秒（00-59） %p 显示本地AM或PM %X 相当于%I:%M:%S %p %Z 显示时区 %A 星期几 (Sunday-Saturday) %a 星期几 (Sun-Sat) %B 完整月份 (January-December) %b 缩写月份 (Jan-Dec) %d 日(01-31) %j 一年中的第几天(001-366) %m 月份(01-12) %Y 完整的年份 按照默认的格式查看当前的系统时间：[caijy@localhost Desktop]$ dateTue Sep 12 20:33:37 CST 2017按照”年-月-日 小时:分钟:秒”的格式查看当前的系统时间：[caijy@localhost Desktop]$ date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-09-12 20:35:30设置当前的系统时间为2017年9月12日21点00分：[caijy@localhost Desktop]$ sudo date -s &quot;20170912 21:00:00&quot;Tue Sep 12 21:00:00 CST 2017再次查看系统时间[caijy@localhost Desktop]$ dateTue Sep 12 21:01:04 CST 2017查看今天是一年中的第几天，其实用这个参数也能够很好的区分备份时间的新旧，即数字越大，越靠近当前时间：[caijy@localhost Desktop]$ date &quot;+%j&quot;255 reboot命令用于重启系统，格式为：”reboot”。重启计算机这种操作会涉及到对硬件资源的管理权限，因此默认只能使用root用户来重启您的电脑：[caijy@localhost Desktop]$ reboot poweroff命令用于关闭系统，格式为：”poweroff”。关机命令也同理，默认只有root管理员用户才可以关闭您的电脑：[caijy@localhost Desktop]$ poweroff wget命令用于在终端中下载网络文件，格式为：“wget [参数] 下载地址”。 参数 说明 -b 后台下载模式 -O 下载到指定mul -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源,包括图片、视频等。 -r 递归下载 ps命令用于查看系统中的进程状态，格式为：“ps [参数]”，常见的ps命令参数有 参数 作用 -a 显示所有的进程（包括其他用户的） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux系统中时刻运行着许许多多的进程，如果能够合理的管理它们，绝对有益于对系统的性能优化，Linux系统中进程最常见的5种不同的状态是运行、中断、不可中断、僵死与停止，它们的含义分别是： R(运行):正在运行或在运行队列中等待。 S(中断):休眠中, 在等待某个条件的形成或接收到信号。 D(不可中断):收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。 Z:(僵死):进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。 T:(停止):进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行。 top命令用于动态的监视进程活动与系统负载等信息，格式为：“top”。这个top命令可真的是太厉害了，它能够动态的查看系统运维状态，完全可以比喻成是“强化版的Windows任务管理器”， top命令前面的五行为系统整体的统计信息： 第1行:系统时间，运行时间，登录终端数，系统负载（分别为1分钟、5分钟、15分钟的平均值，数值越小意味着负载越低）。 第2行:进程总数，运行中的，睡眠中的，停止的，僵死的。 第3行:用户占用资源，系统内核占用资源，改变过优先级的进程，空闲的资源，等待输入输出的时间。此行数据均为CPU数据并以百分比格式显示，例如”99.2 id”意味着有99.2%的CPU处理器资源正在空闲中。 第4行:物理内存总量，使用量，空闲量，作为内核缓存的内存量。 第5行:虚拟内存总量，使用量，空闲量，已被提前加载的内存数据。 pidof命令用于查询某个指定服务进程的PID号码值，格式为：“pidof [参数] [服务名称]”。PID值是区别每个进程的唯一号码，每次在计算机上运行相同的服务程序都很少会获得同样值的PID号码，例如查询下本机sshd服务程序的PID进程号码值：[caijy@localhost Desktop]$ pidof sshd1736 kill命令用于终止某个指定PID号码的服务进程，格式为：“kill [参数] [进程PID号]”。咱们来动手把上面pidof命令查询到的PID号码给终止掉吧，这样操作的效果等同于把sshd服务强制停止。[caijy@localhost Desktop]$ sudo kill 1736killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。(目前尚未安装网卡，找个例子)[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 平时在系统终端中执行一个命令后如果想立即的停止它，您可以同时按下系统组合键“Ctrl+c”，这样命令的进程将会立即被终止，是生产工作中比较常用的命令行快捷键之一。或者有些命令在执行时会不断的在屏幕上输出信息，影响到咱们继续输入命令了，便可以在执行命令时在命令最后面添加上一个“&amp;”符号，这样命令从开始执行就默认被放到系统后台了。 常用系统工作命令为了更好的了解Linux服务器，成为一名合格的运维人员，您必须具备快速查看Linux系统运行状态的能力，因此接下来咱们会逐个来学习下对于网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断命令的使用方法，都是超级实用的Linux命令哦~ ifconfig用于获取网卡配置与网络状态等信息:格式为”ifconfig [网络设备] [参数]”。查看本机当前的网卡配置与网络状态等信息，主要就是看每段开头的网卡名称、inet参数后面的IP地址、ether参数后面的MAC网卡物理地址以及RX、TX的接收与发送数据包的流量大小。 uname命令用于查看系统内核与系统版本等信息，格式为：“uname [-a]”。一般会固定搭配上-a参数来完整查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息:[caijy@localhost Desktop]$ uname -aLinux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux顺便说下，如果您想查看当前系统版本的详细信息需要看redhat-release文件：[caijy@localhost Desktop]$ cat /etc/redhat-releaseRed Hat Enterprise Linux Server release 7.0 (Maipo) uptime命令用于查看系统的负载信息，格式为：“uptime”。这个命令可以为您显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息数据。平均负载值指的是最近1分钟、5分钟、15分钟的系统压力情况（下面加粗的信息部分），负载值越低越好[caijy@localhost Desktop]$ uptime21:14:39 up 31 min, 2 users, load average: 0.20, 0.19, 0.14 free命令用于显示当前系统中内存的使用量信息，格式为：“free [-h]”。为了保证Linux系统不会因硬件故障而突然卡住宕机，那么内存使用量当之无愧是运维人员最应该时刻要关注的数据对象啦，可以使用-h参数来以更人性化的样输出当前内存的实时使用量信息 who命令用于查看当前登入主机的用户终端信息，格式为：”who [参数]”。简单三个字母就可以快捷的显示出所有正在登录着本机的用户名称以及他们正在开启的终端信息： last命令用于查看所有系统的登入记录，格式为：”last [参数]”。使用last命令可以看到本机的登录记录，但由于这些信息都是被以日志文件的形式保存在系统中的数据内容，骇客们很轻易的便可对内容进行篡改，所以千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！ history命令用于显示历史执行过的命令，格式为：“history [-c]”。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录，觉得1000不够用的话还可以修改/etc/profile文件的HISTSIZE变量值，或者使用-c参数来清空里面的历史数据，还可以使用“!编码数字”的方式来重复执行某一次的命令，有很多种有趣的玩法： 历史命令会被保存到用户家目录中的”.bash_history”文件中。Linux系统中以点(.)开头的文件均代表隐藏文件，一般大多会是系统服务文件。[caijy@localhost Desktop]$ cat ~/.bash_history清空该用户在本机中执行的Linux命令历史记录信息：[caijy@localhost Desktop]$ history -c sosreport命令用于收集系统配置并诊断信息后输出结论文档，格式为：“sosreport”。。。有待学习 工作目录切换命令pwd命令用于显示当前所处的工作目录，格式为：“pwd [选项]”。[caijy@localhost Desktop]$ pwd/home/caijy/Desktop cd命令用于切换工作路径，格式为：“cd [目录名称]”。这个命令应该是最最常用的Linux命令之一了，您可以通过cd命令来便捷的切换到不同的工作目录。除了常见的切换目录的方式，还可以使用“cd -”命令来返回到上一次所处的目录或使用“cd ~”命令来切换到当前用户的家目录，亦或使用“cd ~username”则可以切换到其他用户的家目录了~例如使用“cd 路径”的方式切换进/etc目录中：[caijy@localhost Desktop]$ cd /etc同样的道理，再尝试切换进/bin目录中：[caijy@localhost etc]$ cd /bin此时返回到上一次的目录（即/etc目录）：[caijy@localhost bin]$ cd -/etc还可以快速的切换到用户自己的家目录呢：[caijy@localhost etc]$ cd ~[caijy@localhost ~]$ ls命令用于显示目录中的文件信息，格式为：“ls [选项] [文件] ”。当咱们处在不同的工作目录下时，能够看到当前目录下的文件也在发生变化，ls命令的“-a”参数看到全部文件（包括隐藏文件），再结合“-l”参数来查看文件的属性、大小等详细信息。整合之后的命令即可实现查看当前目录中所有文件列表并输出这些文件的属性信息：需要看目录属性信息的话，需要额外添加一个-d参数才可以，例如查看/etc目录的权限与属性信息：[caijy@localhost ~]$ ls -ld /etcdrwxr-xr-x. 132 root root 8192 Sep 12 20:48 /etc 文本文件编辑命令在Linux系统中一切都是文件，而对于服务程序的配置自然也就是在编辑程序的配置文件，如果不能熟练的查阅数据，那以后工作时可就真的要尴尬了。接下来学习几条用于查看文本文件内容的命令吧cat命令用于查看纯文本文件（较短的），格式为：“cat [选项] [文件]”。Linux系统中有需要用于查看文本内容的命令，但其中每个命令又都有自己的特色特点，比如这个cat命令就是用于查看比较精简的文本内容的。这个其实是最好记的命令之一，因为cat在英语中是猫的意思，小猫咪是不是总给您一种娇小、可爱的感觉呢？另外如果您想看文本内容时还顺便显示行号的话，不妨再追加一个“-n”参数试试吧：more命令用于查看纯文本文件（较长的），格式为：“more [选项] 文件”。对于长篇的文本内容，推荐使用more命令来查看文本内容，不仅可以提示您已经阅读了百分之多少，还可以使用空格或回车键向下翻页：head命令用于查看纯文本文档的前N行，格式为：“head [选项] [文件]”。tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为：“tail [选项] [文件]”。当然咱们还会遇到一种更奇葩的情况，比如需要去查看文本内容的最后20行，那么操作方法其实跟head命令是非常相似的，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。而tail命令最强悍的功能是用于持续刷新一个文件的内容，尤其是对于想要实时看到最新日志文件的时候特别有用：tr命令用于替换文本文件中的字符，格式为:“tr [原始字符] [目标字符]”。例如试试把某个文本内容完整替换成大写英文吧：[caijy@localhost Desktop]$ cat 2.txtabcdefghijklmnopqrstuvwxyz[caijy@localhost Desktop]$ cat 2.txt | tr [a-z] [A-Z]ABCDEFGHIJKLMNOPQRSTUVWXYZ wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 例如可以使用“-l”参数来统计行数，而passwd是用于保存系统帐户信息的文件，因此下面的命令就是用于统计当前系统中有多少个用户的作用啦：[caijy@localhost Desktop]$ wc -l /etc/passwd38 /etc/passwd stat命令用于查看文件的具体存储信息和时间等信息，格式“stat 文件名称”。 cut命令用于按“列”来提取文本字符，格式为：“cut [参数] 文本”。如何准确的提取出最想要的数据，这也应该是咱们学习研究的方向之一，按基于“行”的方式来提取是比较简单的，只需要设置好要搜索的关键词即可，但是按列搜索的话不仅要使用“-f”参数来设置需要看的列数，还必须使用“-d”参数来设置间隔符号。因为passwd是用于保存用户信息数据的文件且每一项值都是通过冒号来间隔的，因此可以来尝试下提取出passwd文件中的用户名信息吧，即提取以:（冒号）为间隔符号的第一列内容：[caijy@localhost Desktop]$ head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[caijy@localhost Desktop]$ cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodydbuspolkitdunboundcolordusbmuxdavahiavahi-autoipdlibstoragemgmtsaslauthqemurpcrpcusernfsnobodyrtkitradvdntpchronyabrtpulsegdmgnome-initial-setuppostfixsshdtcpdumpcaijy diff命令用于比较多个文本文件的差异，格式为：”diff [参数] 文件”。仅仅显示比较后的结果，判断文件是否相同：diff --brief diff_A.txt diff_B.txt使用详细的上下文输出格式来描述文件内容具体的不同：diff -c diff_A.txt diff_B.txt 文件目录管理命令touch命令用于创建空白文件与设置文件的各种时间，格式为：“touch [选项] [文件]”。touch命令能够创建出空白的文本文件，但这实在太简单不需要去讲，例如“touch linuxprobe”这样就可以创建出一个空白的名为linuxprobe的文本文件，而有难度的操作主要是用于设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）。 参数 作用 -a 仅修改访问时间“atime” -m 仅修改更改时间“mtime” -d 同时修改atime与mtime [caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16314 Sep 12 21:42 1.txt[caijy@localhost Desktop]$ echo &quot;hello,linux&quot; &gt;&gt; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Sep 13 19:46 1.txt[caijy@localhost Desktop]$ touch -d &quot;2017-06-06 12:22&quot; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Jun 6 12:22 1.txt mkdir命令用于创建空白的文件夹，格式为：“mkdir [选项] 目录”。在Linux系统中文件夹是最常见的文件类型之一，除了能创建单个目录外，还可以使用“-p”参数来递归创建出具有嵌套叠层关系的文件目录。[caijy@localhost Desktop]$ mkdir linux[caijy@localhost Desktop]$ cd linux[caijy@localhost linux]$ mkdir -p a/b/c/d[caijy@localhost linux]$ cd a[caijy@localhost a]$ cd b[caijy@localhost b]$ cp命令用于复制文件或目录，格式为：“cp [选项] 源文件 目标文件”。在Linux系统中的复制操作具体还分为3种情况，第一种情况是如果目标对象是个目录，则会把源文件复制到该目录中.，第二种情况是如果目标对象也是个普通文件，则会询问是否要覆盖它.最后是第三种的情况了，如果目标文件是不存在的，则会是正常的复制操作啦。 参数 作用 -p 保留原始文件的属性 -d 若对象为”链接文件”，则保留该”链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p,d,r为上述的参数） 首先创建一个名为install.log的普通空白文件，然后把其复制出来一份名为x.log的备份文件：[caijy@localhost Desktop]$ touch install.log[caijy@localhost Desktop]$ cp install.log x.log[caijy@localhost Desktop]$ lsinstall.log x.log mv命令用于移动文件或改名，格式为：“mv [选项] 源文件 [目标路径|目标文件名]”。剪切操作不同于复制操作，因为它会默认把源文件删除掉，操作后就只有剪切后的文件了，并且如果对一个文件在同一个目录中进行剪切操作，其实也是重命名的作用：[caijy@localhost Desktop]$ mv x.log linux.log rm命令用于删除文件或目录，格式为：“rm [选项] 文件”。使用“-i”参数删除文件时向您询问是否要执行删除操作，您可以使用“-f”参数来直接强制删除，另外想要删除一个目录文件夹的话就需要再追加一个“-r”参数才可以，否则是删除不掉的，例如来尝试删除下刚刚那两个文件吧：[caijy@localhost Desktop]$ lsinstall.log linux.log[caijy@localhost Desktop]$ rm -i install.logrm: remove regular empty file ‘install.log’? y[caijy@localhost Desktop]$ rm -rf linux.log[caijy@localhost Desktop]$ ls[caijy@localhost Desktop]$ dd命令用于指定大小的拷贝文件或指定转换文件，格式为：“dd [参数]”。dd命令是个比较重要且具有特色的一个命令，它能够让用户指定数据块的大小和个数来复制一个文件的内容，当然如果您愿意的话还可以在复制过程中转换其中的数据。Linux系统中有一个叫做/dev/zero的设备文件，这个文件不会占用您的系统存储空间，但里面却可以提供无穷无尽的数据，因此用dd命令来生成出来一个指定大小的文件是再好不过的了。 参数 作用 if 输入的文件名称。 of 输出的文件名称。 bs 设置每个“块”的大小。 count 设置要拷贝“块”的个数。 [caijy@localhost Desktop]$ dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 2.62394 s, 224 MB/s dd命令也绝对不仅限于复制文件这么简单，如果您想把一个光盘设备制作成iso格式的镜像文件，在Windows系统中一定免不了要用到第三方软件才能做到，但在Linux系统中就可以直接使用dd命令来复制并压制光盘设备变成一个可立即使用的iso镜像哦，例如：[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s file命令用于查看文件的类型，格式为：“file 文件名”。如此看来在Linux系统中文本、目录、设备等等这些一切都会可以被统称为文件，而咱们一般又不能单凭后缀就知道具体的文件类型，这时只能用file命令来查看下文件类型啦~[caijy@localhost Desktop]$ touch linux.log[caijy@localhost Desktop]$ file linux.loglinux.log: empty[caijy@localhost Desktop]$ file /dev/sda/dev/sda: block special 打包压缩与搜索命令tar命令用于对文件打包压缩或解压，格式为：“tar [选项] [文件]”。Linux系统中常见的格式比较多，主要使用的是.tar或.tar.gz或.tar.bz2格式，大部分都是由tar命令来完成的，首先“-c”参数是用于创建压缩文件的，“-x”参数是用于解压文件的，因此这两个不能同时放一起使用，其次“-z”参数是指定使用Gzip格式来压缩解压文件，“-j”参数是指定使用bzip2格式来压缩解压文件。解压时候则是根据文件的后缀来决定是何种格式参数，而有些打包操作要数个小时，屏幕没有输出的话您一定会怀疑电脑死机了，也不好判断打包的进度情况，因此非常推荐使用“-v”参数来不断显示压缩或解压的过程给用户，“-C”参数用于指定要解压到的哪个指定的目录，而“-f”参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。我会一般使用“tar -czvf 压缩包名称.tar.gz 要打包的目录”命令来把指定的文件来打包压缩，解压的话则是“tar -xzvf 压缩包名称.tar.gz”命令，接下来使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：[caijy@localhost Desktop]$ tar -czvf etc.tar.gz /etctar: Removing leading `/&#39; from member names/etc//etc/fstabtar: /etc/crypttab: Cannot open: Permission denied/etc/mtab/etc/fonts//etc/fonts/conf.d//etc/fonts/conf.d/65-0-lohit-bengali.conf...... 然后把刚刚打包的压缩包文件指定解压到mydir目录中：[caijy@localhost Desktop]$ tar -xzvf etc.tar.gz -C mydiretc/etc/fstabetc/mtabetc/fonts/etc/fonts/conf.d/etc/fonts/conf.d/65-0-lohit-bengali.conf grep命令用于对文本内容进行关键词的搜索匹配，格式为：“grep [选项] [文件]”。可以把grep命令当作是用途最广泛的文本搜索匹配工具，参数虽然很多但基本是用不到的.这里只说两个最最最常用的参数，只要会使用“-n”参数显示搜索到信息的行号，使用“-v”参数用于反选信息（即没有包含关键词的所有信息行）。Linux系统中的/etc/passwd文件是保存着所有用户信息的文件，而一旦用户的登录终端被设置成“/sbin/nologin”则不再允许登录系统，因此可以通过使用grep命令来匹配出当前系统中所有不允许登录系统的用户信息：[caijy@localhost Desktop]$ grep -n /sbin/nologin /etc/passwd2:bin:x:1:1:bin:/bin:/sbin/nologin3:daemon:x:2:2:daemon:/sbin:/sbin/nologin4:adm:x:3:4:adm:/var/adm:/sbin/nologin5:lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin...... find命令用于在Linux系统中按照指定条件查找文件，格式为：“find [查找路径] 寻找条件 操作”。“Linux系统中的一切都是文件”，在Linux系统中的搜索工作一般都是通过find命令来完成的，它可以根据不同的文件特性来做为匹配项（如文件名、大小、修改时间、权限等信息），一旦匹配到了则会默认为用户显示到屏幕上来，基础的匹配项目请见下表即可。我主要讲解下“–exec”参数重要的作用，这个参数是用于把find命令搜索到的结果交由给后面的命令再进一步做处理，十分类似于后面博文提到的管道符技术。 参数 作用 -name 匹配名称 -perm 匹配权限（mode为完全匹配，-mode为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime 匹配修改内容的时间（-n指n天以内，+n指n天以前） -atime -n +n 匹配访问文件的时间-n指n天以内，+n指n天以前 -ctime -n +n 匹配修改权限的时间-n指n天以内，+n指n天以前 -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件f1新却比f2旧的文件 –type b/d/c/p/l/f 匹配文件类型（块设备、目录、字符设备、管道、链接文件、文件文件） -size 匹配文件的大小（+50k查找超过50k的文件,而-50k则代表查找小于50k的文件） -prune 忽略某个目录 -exec {} \; 后面可接对搜索到结果进一步处理的命令（下面会有演示） Linux系统中的配置文件根据FHS协议会被保存到/etc目录中，如果要想获取到该目录中所有以host开头的文件列表就可以这样做：[caijy@localhost Desktop]$ sudo find /etc -name &quot;host*&quot; -print[sudo] password for caijy:/etc/avahi/hosts/etc/host.conf/etc/hosts 想要在整个系统中搜索所有权限中包括SUID权限的文件，只需使用减号-4000即可：[caijy@localhost Desktop]$ sudo find / -perm -4000 -print/usr/bin/fusermount/usr/bin/su/usr/bin/chage/usr/bin/gpasswd...... 转载自：http://www.linuxprobe.com/chapter-02.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程01]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B01%2F</url>
    <content type="text"><![CDATA[经济有限，笔者在虚拟机上安装的“红帽”，具体安装步骤在此不展开论述，不会的同学参考虚拟机/红帽安装及工具下载。 重置root用户密码记得笔者一次面试的时候被问到：如果忘记MySQL root用户的密码怎么办？我一想，这种问题就该直接谷歌，结果被鄙视一脸。后来查了一下，无非是几个命令。在此记录这个比较重要的问题，此处以红帽系统为例（大家先确认自己的Linux系统是不是红帽）： 重启Linux，在引导界面按“e” 在linux16参数这行的后面追加“rd.break”参数并同时一起按下键盘“ctrl“和“x”按键来执行内核参数 过一会儿便进入系统的紧急求援模式。依次输入一下命令（其中第三行命令的“123456”是你新的root用户密码）： mount -o remount,rw /sysroot chroot /sysroot echo “123456” | passwd –stdin root touch /.autorelabel exit reboot然后等待重启即可 RPM红帽软件包这里总结一下常用的软件包命令： 安装软件的命令格式:rpm -ivh filename.rpm 升级软件的命令格式:rpm -Uvh filename.rpm 卸载软件的命令格式:rpm -e filename.rpm 查询软件的描述信息的命令格式:rpm -qpi filename.rpm 列出软件的文件信息的命令格式:rpm -qpl filename.rpm 查询文件属于哪个RPM的命令格式:rpm -qf filename Yum软件仓库Yum软件仓库是为了进一步降低软件安装难度和复杂度而设计的技术，Yum软件仓库可以根据用户的要求分析出所需软件包及其相关依赖关系，然后自动从服务器下载软件包并安装到系统，下面的Yum命令过一下即可。 命令 作用 yum repolist all 列出所有仓库 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 yum remove 软件包名称 移除软件包 yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove 软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 Systemd初始化进程Linux操作系统开机过程首先从BIOS开始，进入“Boot Loader”，加载系统内核，，内核进行初始化，启动初始化进程。初始化进程作为系统第一个进程，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。systemd初始化进程服务采用了并发启动机制，开机速度得到了不小的提升。红帽RHEL7系统启动时要做大量的初始化工作，例如挂在文件系统和交换分区。启动各类进程服务等操作，这些都可以看作一个个的单元（Unit），即用”目标(target)”代替了“运行级别”这个概念，区别如下表所示： Sysvinit运行级别 System目标名称 作用 0 runlevel0.target, poweroff.target 关机 1 runlevel1.target, rescue.target 单用户模式 2 runlevel2.target, multi-user.target 等同于级别3 3 runlevel3.target, multi-user.target 多用户的文本界面 4 runlevel4.target, multi-user.target 等同于级别3 5 runlevel5.target, graphical.target 多用户的图形界面 6 runlevel6.target, reboot.target 重启 emergency emergency.target 紧急Shell 红帽RHEL6系统使用service、chkconfig等命令来管理系统服务，红帽RHEL7系统中管理服务使用的是systemctl命令：systemctl管理服务的启动、重启、停止、重载、查看状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 service foo start systemctl start foo.service 启动服务 service foo restart systemctl restart foo.service 重启服务 service foo stop systemctl stop foo.service 停止服务 service foo reload systemctl reload foo.service 重新加载配置文件（不终止服务） service foo status systemctl status foo.service 查看服务状态 systemctl设置服务的开机启动、不启动、查看各级别下服务启动状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 chkconfig foo on systemctl enable foo.service 开机自动启动 chkconfig foo off systemctl disable foo.service 开机不自动启动 chkconfig foo systemctl is-enabled foo.service 查看特定服务是否为开机自启动 chkconfig –list systemctl list-unit-files –type=service 查看各个级别下服务的启动与禁用情况 转载自：http://www.linuxprobe.com/chapter-01.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Linux Blog]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。 –《Linux就该这么学》读书笔记]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
