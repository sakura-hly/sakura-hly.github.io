<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础课程04]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F14%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B04%2F</url>
    <content type="text"><![CDATA[首先来学习如何使用vim编辑器来编写、修改文档，然后通过逐个配置主机名称、系统网卡以及Yum仓库参数文件等实验来加深对vim编辑器中诸多命令、快捷键的执行方法与各个模式切换的方法。然后把前面的Linux命令、命令语法与Shell脚本中的if条件测试语句、for条件测试循环语句、while条件循环语句以及case条件测试语句通过vim编辑器写到Shell脚本中结合到一起，实现最终能够自动化工作的软件脚本工具。最后为读者们演示了怎样通过at命令与crond计划任务服务来分别实现一次性与长期性的系统任务设置方法，让日常的工作更加高效自动化，一劳永逸。 Vim文本编辑器“Linux系统中一切都是文件，而配置一个服务就是在修改其配置文件的参数”。而且在日常工作中也一定免不了遇到编写文档的事情吧，这些都是要通过文本编辑器来完成的，咱们选择学习vim这个当前整个linux操作系统中都会默认安装好的一款超棒文本编辑器，学会后绝对会能让您“通吃”当前主流的系统。Vim能够得到广大厂商与众多用户的认可，原因就是在Vim编辑器中内设有的三种模式——命令模式、末行模式 和 编辑模式，每种模式分别又支持多种不同的命令快捷键组合，大大的提高了工作效率，用习惯后会觉得非常的顺手。而要想在文本操作时更加高效率，就必须先搞清Vim编辑器的三种模式的操作不同与切换方法： 命令模式：控制光标移动，可对文本进行删除、复制、粘贴和查找等工作。 输入模式：正常的文本录入。 末行模式：保存、退出与设置编辑环境。 每次运行vim编辑器后都默认会是 “命令模式”，需要先进入到 “输入模式” 后再进行编写文档的工作，而每次编辑完成需先返回到 “命令模式” 后再进入 “末行模式” 中执行对文本的保存或退出操作，并不能直接从 “输入模式” 切换到 “末行模式” 。vim编辑器内设支持的命令有成百上千种用法，为了能够帮助读者更快的掌握vim编辑器，刘遄老师分别总结了在 命令模式 和 末行模式 中最常用的一些快捷键命令，如下表所示： 命令 作用 dd 删除（剪切）光标所在整行。 5dd 删除(剪切)从光标处开始的5行。 yy 复制光标所在整行 5yy 复制从光标处开始的5行。 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后。 /字符串 在文本中从上至下搜索该字符串。 ?字符串 在文本中从下至上搜索该字符串。 末行模式主要用于保存或退出文件，能够设置vim编辑器的整体使用环境，还可以让用户执行外部Linux命令或跳转到特定的行数，切换到末行模式的方式就是在命令模式中输入一个冒号就可以的，末行模式中可用的命令如下表： 命令 作用 :w 保存 :q 推出 :q! 强制推出 :wq! 强制保存退出 :set nu 设置行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two 编写简单文档现在就让咱们一起动手编写个简单的文档吧，编写脚本的第1步就是给文件取个名字，如果文档的名称存在则打开它，如果不存在则是创建一个临时的输入文件。[root@localhost workdir]# vim practice.txt进入文件后默认看到的是vim编辑器的命令模式，这时只能够执行命令快捷键而不能随意输入文本内容，必须切换到输入模式才可以开始编写工作。有些读者应该能够猜出a、i、o三键的区别了吧，对，就是光标的位置不同！a键与i键分别是在光标右一位和光标当前位置切换到输入模式，而o键则是在光标的下面再创建一个空行，此时可敲击a键进入到编辑器的输入模式，输入模式是可以随意输入文本内容的，更不会把您输入的文本内容当作命令而执行:如果想要保存并退出这个文本文件，必须先从 输入模式 返回到 命令模式，然后切换至 末行模式 中才能完成保存退出操作。当咱们在末行模式中键入:wq!时就意味着强制保存并退出文件，然后便可以用cat命令查看到保存文件后的信息了[root@localhost workdir]# cat practice.txtYou can write in it. 感觉是不是很简单，咱们接下来继续编辑这个文件，因为要在原有文本的内容下面追加内容，所以在命令模式中敲击o键的话会更高效呢.现在是不是感觉对vim编辑器有了一些实战经验呢，也不是想象中的那么难吧~现在咱们查看下文本的内容会发现果然后面一次输入的内容并没有被保存下来:[root@localhost workdir]# cat practice.txtYou can write in it. 配置主机名称为了便于在局域网中指定查找某个用户的电脑或区别主机的作用，除了要有IP地址外还要配置一个主机名，用户之间可以通过这个类似于域名的名称来便捷的相互访问。绝大部分的Linux系统主机名都是保存在/etc/hostname文件中的，咱们要想将其内容修改为”linuxprobe.com”，思路大致如下： 使用vim编辑器修改”/etc/hostname”主机名称文件。 把原始主机名称删除后追加”linuxprobe.com”。 保存退出文档并用hostname命令检查是否修改成功。 使用hostname命令查看当前的主机名称，但有时系统不能立即同步到主机名称已经发生改变，所以如果您确认修改完成却还显示原来的主机名称，可重启虚拟机后再查看下：[root@localhost workdir]# hostnamecaijy.com 配置网卡信息能够正确的配置网卡IP地址是保证两台服务器互相通信的前提，而Linux系统中的一切都是文件，配置网络的工作其实就是在编辑网卡配置文件，因此这个小任务不仅是帮助您熟练操作vim编辑器的过程，还是在为以后学习各种服务课程打下深深的基础。 在红帽RHEL7系统中的网卡配置文件前缀则以 “ifcfg-eno” 开始的,例如现在要想配置一个名称为eno16777736的网卡设备开机自启动并且IP地址、子网、网关等信息由人工指定的话思路应该是： 首先要切换到”/etc/sysconfig/network-scripts”目录中（该目录存放着网卡的配置文件）。 使用vim编辑器修改网卡文件”ifcfg-eno16777736”，逐项写入配置参数并保存退出，因每台电脑的硬件及架构情况都是不一样的，同学们的网卡默认名称请通过ifconfig命令自行确认。 设备类型:TYPE=Ethernet 地址分配模式:BOOTPROTO=static 网卡名称:NAME=eno16777736 是否启动:ONBOOT=yes IP地址:IPADDR=192.168.10.10 子网掩码:NETMASK=255.255.255.0 网关地址:GATEWAY=192.168.10.1 DNS地址:DNS1=192.168.10.1 重启网卡设备并测试网络是否联通。 进入到网卡配置文件所在的目录，然后编辑网卡配置文件填入下面的信息：执行重启网卡设备的命令，正常情况不会有提示信息，然后通过ping命令测试网络能否联通。[root@localhost network-scripts]# systemctl restart network[root@localhost network-scripts]# ping 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.029 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.032 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.032 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.040 ms64 bytes from 192.168.10.10: icmp_seq=5 ttl=64 time=0.066 ms64 bytes from 192.168.10.10: icmp_seq=6 ttl=64 time=0.031 ms^C--- 192.168.10.10 ping statistics ---6 packets transmitted, 6 received, 0% packet loss, time 5002msrtt min/avg/max/mdev = 0.029/0.038/0.066/0.013 ms 配置Yum仓库前面了解过Yum软件仓库的作用是为了进一步简化RPM管理软件难度以及自动分析所需软件包及其依赖关系的技术。您可以把Yum想象成是一个硕大的软件仓库，里面保存有几乎所有常用的工具，而只需要说出所需的软件包名称，系统就会自动的为您搞定一切。那么既然要使用Yum技术，就要先把软件仓库搭建起来，然后将其配置规则确定好才行 首先要进入到”/etc/yum.repos.d/“目录中（因为该目录存放着yum仓库的配置文件） 使用vim编辑器创建一个名为rhel7.repo的新配置文件（文件名称可随意，但后缀必须为repo），逐项写入下面加粗的配置参数并保存退出（不写中文注释）。 [rhel-media] yum仓库唯一标识符，避免与其他仓库冲突。 name=linuxprobe yum仓库的名称描述，易于识别仓库用处。。 baseurl=file:///media/cdrom 提供方式包括FTP（ftp://..）、HTTP（http://..）、本地（file:///..） enabled=1 设置此源是否可用，1为可用，0为禁用。 gpgcheck=1 设置此源是否校验文件，1为校验，0为不校验。 gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release 若为校验请指定公钥文件地址。 按配置参数的路径把光盘挂载，并把光盘挂载信息写入到/etc/fstab文件中。 使用”yum install httpd -y”命令检查Yum仓库是否已经可用。 进入到/etc/yum.repos.d目录中后创建Yum配置文件：[root@localhost network-scripts]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# vim rehl17.repo[rhel7]name=rhel7baseurl=file:///media/cdromenabled=1gpgcheck=0 创建挂载点后进行挂载操作，并设置成开机自动挂载[root@localhost yum.repos.d]# mkdir -p /media/cdrom[root@localhost yum.repos.d]# mount /dev/cdrom /media/cdrommount: /dev/sr0 is write-protected, mounting read-only[root@localhost yum.repos.d]# vim /etc/fstab/dev/cdrom /media/cdrom iso9660 defaults 0 0 尝试使用Yum软件仓库来安装Web服务，出现Complete（完成）则代表Yum仓库配置正确：[root@localhost yum.repos.d]# yum install httpdLoaded plugins: langpacks, product-id, subscription-managerThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.......Complete! 编写Shell脚本Shell终端解释器被形容是人与计算机硬件的“翻译官”，它作为用户与Linux系统内部通讯的媒介，除了允许了各种变量与参数外还提供了诸如循环、分支等高级语言才有的控制结构特性，如何正确的使用这些功能，准确下达命令尤为重要。Shell脚本的工作方式有两种，首先是前面所接触的交互方式(Interactive)，即当用户每输入一条命令就执行一次，而批处理(Batch)则是由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。因此在Shell脚本中不仅需要用到很多前面学习过的Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行加工，最终才能成为日常所见的Shell脚本程序，可以通过SHELL变量来查看到当前系统已经默认使用bash解释器作为命令行终端了：[root@localhost Desktop]# echo $SHELL/bin/bash 编写简单的脚本估计读者看完上面对Shell脚本如此复杂的描述都有一种心累想放弃的感觉了吧，但这仅指的是一个高深Shell脚本的编写原则，其实使用vim编辑器把linux命令按照顺序依次写入文件就是编写完成一个最简单的脚本啦。例如想查看当前所在工作路径并列出当前目录下所有文件及属性信息，编写一个脚本来完成的话是这样：[root@localhost Desktop]# vim example.sh#! /bin/bash#For Examplepwdls -alShell脚本文件的名称是可以任意起，但咱们应该遵守运维行业人员大众的规范把.sh后缀写上，这样让其他人一看就知道是个脚本文件，与人方便自己方便。在这个脚本中实际上出现了三种不同的元素，第一行脚本声明(#!)是用来告知系统用何种shell解释器来执行本脚本程序，第二行注释信息(#)是对程序功能和某些命令的介绍信息，使得自己或他人再次看到这个脚本内容时可以快速知道这些功能的作用或一些警告信息，第三、四行可执行语句也就是咱们平时执行的Linux命令啦~什么？同学们不相信这么简单就编写出来了一个脚本程序，那来执行看一看吧：[root@localhost Desktop]# bash example.sh/home/caijy/Desktoptotal 4848drwxr-xr-x. 4 caijy caijy 93 Sep 14 16:29 .drwx------. 14 caijy caijy 4096 Sep 14 11:05 ..drwxrwxr-x. 3 caijy caijy 20 Sep 14 12:34 c-rw-rw-r--. 1 caijy caijy 4946304 Sep 13 20:29 etc.tar.gz-rw-r--r--. 1 root root 38 Sep 14 16:28 example.sh-rw-rw-r--. 1 caijy caijy 0 Sep 13 20:21 linux.logdrwxrwxr-x. 2 caijy caijy 4096 Sep 13 21:06 mydir-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt第二种运行脚本程序的方法是以输入完整路径的方式来执行，但默认会因为权限不足而提示报错信息，这种情况只需要为脚本文件增加执行权限即可:[root@localhost Desktop]# ./example.shbash: ./example.sh: Permission denied[root@localhost Desktop]# chmod u+x example.sh[root@localhost Desktop]# bash example.sh/home/caijy/Desktoptotal 4848drwxr-xr-x. 4 caijy caijy 93 Sep 14 16:29 .drwx------. 14 caijy caijy 4096 Sep 14 11:05 ..drwxrwxr-x. 3 caijy caijy 20 Sep 14 12:34 c-rw-rw-r--. 1 caijy caijy 4946304 Sep 13 20:29 etc.tar.gz-rw-r--r--. 1 root root 38 Sep 14 16:28 example.sh-rw-rw-r--. 1 caijy caijy 0 Sep 13 20:21 linux.logdrwxrwxr-x. 2 caijy caijy 4096 Sep 13 21:06 mydir-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt 接收用户的参数但是像上面这样的脚本程序在功能上真的太过于“死板”，为了能够让Shell脚本程序更好的满足用户对灵活完成工作的热切需要，必须要让脚本程序能够像咱们以前执行命令时那样来接收用户输入进来的参数。 其实Shell脚本早就考虑到了这些，已经在脚本中定义好了很多变量功能，例如$0对应当前Shell脚本程序的名称，$#对应总共有几个参数，$*对应所有位置的参数值，而$1,$2,$3……依次类推则分别对应着第N个位置的参数:尝试来编写一个测试用的脚本程序，通过引用上面的变量参数来看下真实效果：[root@localhost Desktop]# vim example.sh#! /bin/bashecho &quot;当前脚本名称为$0.&quot;echo &quot;总共有$#个参数，分别是$*.&quot;echo &quot;第1个参数为$1,第5个为$5.&quot;[root@localhost Desktop]# bash example.sh one two three four five当前脚本名称为example.sh.总共有5个参数，分别是one two three four five.第1个参数为one,第5个为five. 判断用户的参数学习就像是在登台阶，在您学习完执行linux命令，掌握脚本语法变量和接收用户输入信息等方法后就要踏上新的高度——即能够进一步去处理接收到的用户的参数。因为有时咱们也需要像前面学习过的mkdir命令一样来判断用户输入的信息，从而判断用户指定的文件夹名称是否已经存在，已存在则提示报错，不存在则自动的创建。条件测试语法能够判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。 条件判断语句按照测试对象可分为 文件测试、逻辑测试、整数值比较与字符串比较，文件测试即用来按照指定条件来判断文件是否存在或权限是否满足，具体的参数包括有： 操作符 作用 -d 测试是否为目录 -e 测试文件或目录是否存在 -f 判断是否为文件 -r 测试当前用户是否有权限读取 -w 测试当前用户是否有权限写入 -x 测试当前用户是否有权限执行 好啦，那么先通过文件测试语句来判断/etc/fstab是否为一个目录文件，然后通过$?变量来显示上一条命令执行后的返回值，这样就可以通过返回的非零值判断目录是不存在的了（即文件测试语句判断结果不符合）：[root@localhost Desktop]# [ -d /etc/fstab ][root@localhost Desktop]# echo $?1再来用文件测试语句来判断下/etc/fstab是否为一般文件，这样看到返回值是0即代表这个一般文件是存在的：[root@localhost Desktop]# [ -f /etc/fstab ][root@localhost Desktop]# echo $?0逻辑测试则是用于判断用户给出的条件是为真还是假，从而把条件测试语句与逻辑语句相搭配结合使用可以实现一个更高级的使用方法，例如在Shell终端中逻辑“与”符号是&amp;&amp;，它代表当前面的命令执行成功后才会执行后面的命令，因此可以用来判断/dev/cdrom设备是否存在，若存在时才输出Exist字样。[root@localhost Desktop]# [ -e /dev/cdrom ] &amp;&amp; echo &quot;exist&quot;exist除了“与”逻辑测试符号外,还有逻辑“或”，“非”符号，在Linux系统中逻辑“非”的符号就是一个叹号，它代表把条件测试中的判断结果取相反值。 整数比较运算符是仅对数字的测试操作，不能把数字与字符串、文件等内容一起操作，而且不能想当然的使用日常生活中的等号、大于号、小于号等来做判断，因为等号与是赋值命令符冲突，大于号和小于号分别是和输出重定向命令符和输入重定向命令符冲突。虽然有时候碰巧也能执行成功，但是在后面脚本程序中普遍会产生错误，一定要使用规范的整数比较运算符来进行操作： 操作符 作用 -eq 判断是否等于 -ne 判断是否不等于 -gt 判断是否大于 -lt 判断是否小于 -le 判断是否等于或小于 -ge 判断是否大于或等于 咱们先小试牛刀的测试下10是否大于10以及10是否等于10，依次通过判断输出的返回值内容来进行判断：[root@caijy Desktop]# [ 10 -gt 10 ][root@caijy Desktop]# echo $?1[root@caijy Desktop]# [ 10 -eq 10 ][root@caijy Desktop]# echo $?0在前面第2章的第四小节中学习过一个叫做free的命令，它能够获取到当前系统正在使用及可用的内存量信息。接下来咱们先用free -m命令查看以兆为单位的内存使用量情况，然后通过grep Mem:命令对关键词匹配过滤出剩余内存量的行，再用awk ‘{print $4}’命令过滤只保留第三列，最后用FreeMem=`语句`的方式把语句内执行的结果赋值给变量，这个演示确实有些难度，但看懂后会觉得很有意思，写到笔记本上在运维工作时也会用得上。[root@caijy Desktop]# free -mtotal used free shared buffers cachedMem: 1826 867 959 9 0 278-/+ buffers/cache: 588 1238Swap: 2047 0 2047[root@caijy Desktop]# free -m | grep -n Mem2:Mem: 1826 867 959 9 0 278[root@caijy Desktop]# free -m | grep -n Mem | awk &#39;{print $4}&#39;955[root@caijy Desktop]# FreeMem=`free -m | grep Mem | awk &#39;{print $4}&#39;[root@caijy Desktop]# echo $FreeMem953上面做的获取内存可用量的步骤有些难度“超纲”了，如果不能够马上理解也不用担心，接下来才是重点，需要通过整数运算符来判断内存可用量的值是否小于1024，若小于则会提示内存不足的字样：[root@caijy Desktop]# [ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot;Insufficient Memory字符串比较是判断测试字符串是否为空值，或两个字符串是否相同的操作，常常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单，常见的操作运算符如下： 操作符 作用 = 比较字符串内容是否相同。 != 比较字符串内容是否不同。 -z 判断字符串内容是否为空。 咱们可以通过判断String变量是否为空值，进而判断是否未被定义：[root@caijy Desktop]# [ -z $String ][root@caijy Desktop]# echo $?0最后再尝试把逻辑运算符引入来试试，当判断用于保存当前语系的环境变量值LANG不是为英语（en.US）则会满足逻辑条件并输出非英语的字样：[root@caijy Desktop]# echo $LANGen_US.utf8[root@caijy Desktop]# [ $LANG != &quot;en.US.utf8&quot; ] &amp;&amp; echo &quot;Not en.US.utf8&quot;Not en.US.utf8]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程03]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F14%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B03%2F</url>
    <content type="text"><![CDATA[我们已经学习了数十个常用的Linux系统命令，以后要把这些命令通过语法结合使用。这里学习Linux命令与文件读写操作有关的重定向技术的五种模式——标准覆盖输出重定向、标准追加输出重定向、错误覆盖输出重定向、错误追加输出重定向、输入重定向。 输入输出重定向简单用一句话来概括即 “使用输入重定向能够把文件导入到命令中，而输出重定向则是能够把原本要输出到屏幕的数据信息写入到指定文件中”。平常输出重定向会使用得多一些，细分之下又有 标准输出重定向 和 错误输出重定向 两种技术以及 清空写入 和 追加写入 两种模式。 标准输入(STDIN，文件描述符为0)：默认从键盘输入，为0时表示是从其他文件或命令的输入。 标准输出(STDOUT，文件描述符为1)：默认输出到屏幕，为1时表示是文件。 错误输出(STDERR，文件描述符为2)：默认输出到屏幕，为2时表示是文件。 对于输入重定向有这些情况： 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见“分界符”才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 对于输出重定向有这些情况： 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt; &amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 试一下吧，通过标准输出重定向将“man bash”命令原本要输出到屏幕的信息写入到文件中去，效果类似于： 有没有感觉到特别方便呢？那么接下来试试输出重定向技术中的 清空写入 与 追加写入 两种不同模式带来的变化吧~先通过清空模式向文件写入一行数据（该文件中包含上一个实验的man命令信息），然后再通过追加模式向文件再写入一次数据，最终咱们看到的文件内容会是这个样子的：[caijy@localhost Desktop]$ echo &quot;Welcome to linux&quot; &gt; readme.txt[caijy@localhost Desktop]$ echo &quot;Quality linux learning materials&quot; &gt;&gt; readme.txt[caijy@localhost Desktop]$ cat readme.txtWelcome to linuxQuality linux learning materials 虽然都是输出重定向技术，但对于不同命令的标准输出和错误输出还都有点区别，例如查看下当前目录中某个文件的信息吧。因为这个文件是真实存在的，因此使用标准输出即可将数据写入到文件中，而错误的输出重定向则不行，依然会把信息输出到了屏幕上。[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l readme.txt &gt; out.txt[caijy@localhost Desktop]$ cat out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt[caijy@localhost Desktop]$ ls -l readme.txt 2&gt; out.txt-rw-rw-r--. 1 caijy caijy 50 Sep 14 10:31 readme.txt 那如果是想把命令的报错信息写入到文件呢？例如当您在执行一个自动化的Shell脚本时会特别的实用，因为可以通过把整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。接下来学习实践中咱们就以一个不存在的文件做演示吧：[caijy@localhost Desktop]$ touch out.txt[caijy@localhost Desktop]$ ls -l xxxls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx &gt; out.txtls: cannot access xxx: No such file or directory[caijy@localhost Desktop]$ ls -l xxx 2&gt; out.txt[caijy@localhost Desktop]$ cat out.txtls: cannot access xxx: No such file or directory 输入重定向作用是把文件直接导入到命令中。接下来使用输入重定向把文件导入给“wc -l”命令来统计下内容行数吧，这样命令其实等同于接下来要学习的“cat readme.txt | wc-l”的管道符命令组合。[caijy@localhost Desktop]$ wc -l &lt; readme.txt2 管道命令符管道符的输入方法是同时按下键盘的“Shift”与“\”键，执行格式为“命令A | 命令B”，其实管道命令符的作用也能用一句话来概括： “把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入” 。回想前面学习过的grep文本搜索命令通过匹配关键词/sbin/nologin找出了所有被限制登录系统的用户，其实只要学完了这个小节，完全可以把下面的两条命令合并到一起。[caijy@localhost Desktop]$ grep &quot;/sbin/nologin&quot; /etc/passwd | wc -l33 学习到了这个管道符就像拿到了一个法宝，让咱们来套用到其他不同的命令上吧，比如用翻页的形式查看/etc目录中的文件列表及属性信息吧（默认会一股脑的都显示到屏幕上，根本看不清楚）： [root@localhost Desktop]# echo &quot;linux&quot; | passwd --stdin rootChanging password for user root.passwd: all authentication tokens updated successfully. 对于这个管道符命令是不是觉得有些相见恨晚？其实玩法还有很多，比如默认发送邮件需要交互式的进行才行，而此时则可以通过一条结合了管道符的命令语句把编辑好的内容与标题一起的“打包”，最终用一条命令就顺利的给用户发送了邮件。[root@localhost Desktop]# echo &quot;Context&quot; | mail -s &quot;Subject&quot; caijy[root@localhost Desktop]# su caijy[caijy@localhost Desktop]$ mailHeirloom Mail version 12.5 7/5/10. Type ? for help.&quot;/var/spool/mail/caijy&quot;: 1 message 1 new&gt;N 1 root Thu Sep 14 11:01 18/612 &quot;Subject&quot; 能不能让这样方便的命令写的更高级一些呢？下面这条自造命令就是通过把mail邮件命令与输入重定向的分界符来结合使用，效果是让用户可以一直的输入内容，直到系统遇到匹配上了用户定义的分界符才最终结束。[root@localhost Desktop]# mail -s &quot;Readme&quot; root@localhost.localdomain &lt;&lt; over&gt; I think linux is very practical&gt; I hope to learn more&gt; can you teach me ?&gt; over 当然大家可不要误解管道命令符只能用一次哦，完全可以这样用：“命令A|命令B|命令C”。 命令行的通配符例如想批量查看所有硬盘文件的相关权限属性，笨笨的命令会是这样的：[root@localhost Desktop]# ls -l /dev/sdabrw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sda[root@localhost Desktop]# ls -l /dev/sda1brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1[root@localhost Desktop]# ls -l /dev/sda2brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda3ls: cannot access /dev/sda3: No such file or directory幸亏我的硬盘文件和分区只有3个，要是有几百个的话，估计一天的工作时间都要忙活这个事了。咱们此时已经能看出一些简单规律了，比如这些硬盘设备文件共性都是以sda开头并且存放到了/dev目录中，那即便不知道分区编号和具体分区的个数也一样可以用通配符来搞定。通配符顾名思义就是通用的匹配信息的符号，比如星号(*)就是代表匹配零个或多个字符，问号(?)是代表匹配单个字符，中括号内加上数字[0-9]代表匹配单个阿拉伯数字的字符，而中括号内加上字母[abc]则是代表匹配单个指定的英文字母。[root@localhost Desktop]# ls -l /dev/sda*brw-rw----. 1 root disk 8, 0 Sep 13 04:43 /dev/sdabrw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2如果只需要看sda后面一定要有个字符的文件相关信息呢？那就要用到问号来通配了。[root@localhost Desktop]# ls -l /dev/sda?brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2您除了可以用[0-9]来通配所有的单个阿拉伯数字，也可以用[135]这样的方式仅匹配这三个指定数字，若没有通配到即不会显示出来：[root@localhost Desktop]# ls -l /dev/sda[0-9]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1brw-rw----. 1 root disk 8, 2 Sep 13 04:43 /dev/sda2[root@localhost Desktop]# ls -l /dev/sda[135]brw-rw----. 1 root disk 8, 1 Sep 13 04:43 /dev/sda1 常用的转义字符Shell解释器为了能够更好的理解您想表达的意思，还提供了特别丰富的转义符号来帮助程序员处理输入的特殊数据。常见的转义字符包括有：反斜杠()的作用就是转义后面的一个变量变为单纯的字符串，单引号(‘’)则是转义其中所有的变量为单纯的字符串，而双引号（””）是保留其中的变量属性不转义，反引号(``)则是把其中的命令执行后返回一个结果。例如咱们先定义一个名称为PRICE的变量并赋值为5，然后通过双引号括起来输出字符串与变量结合的结果：[root@localhost Desktop]# PRICE=5[root@localhost Desktop]# echo &quot;Price is $PRICE&quot;Price is 5[root@localhost Desktop]# echo &quot;Price is $$PRICE&quot;Price is 44837PRICE原本刚刚是希望能够进一步输出“Price is $5”即价格是五美元的字符串信息，但碰巧美元符号与变量提取符号冲突了，因此输出的并不是预想的信息。需要用转义符把第一个$符号转换成单纯的字符串，再或者把整段都转义成单纯的字符串吧（当然这个只是让您看下效果，并不符合实验需要）：[root@localhost Desktop]# echo &quot;Price is \$$PRICE&quot;Price is $5[root@localhost Desktop]# echo &#39;Price is \$$PRICE&#39;Price is \$$PRICE 最后一个您可能看到结果时会觉得很无用，因此暂且先不用管具体的使用场景，就当作是提前为SHELL编程知识学习做一点小小的铺垫吧。如果只需要某个命令的返回输出值时，就可以用像 命令 这样用反引号括起来的命令格式来达到效果，例如通过反引号与uname -a命令结合通过返回值来查看下本机版本和内核信息吧：[root@localhost Desktop]# echo `uname -a` Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux 重要的环境变量变量是计算机系统中用于保存可变值的数据类型，在Linux系统中一般变量名称都是大写的，这仅算是一种约定俗成的规范，平时可以直接通过变量名称来提取到对应的变量值。Linux系统中的环境变量是用来指定系统运行环境的一些参数，比如每个用户不同的家目录、邮件保存存放位置等等。 前面小节中提到的一个概念——即Linux系统中一切都是文件，因此Linux命令肯定也不例外，那当用户执行了一条命令之后到底发生了什么事情呢？简单来说就是四个步骤： 第1步骤阶段是判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话则直接执行。 第2步骤阶段是检查用户输入的命令是否为“别名命令”，即用一个自创的命令名称来替换原本的命令名称。可以用alias命令来创建一个属于自己的命令别名，格式为: alias 新的命令=’原命令 -选项/参数’，若要取消一个别名的话则是用unalias命令，格式为：“unalias 别名”。例如以前每次用rm命令删除文件的时候都要被要求再确认是否执行删除操作，其实这就是Linux系统为了防止用户误删除文件而特意设置的rm别名命令，咱们可以把它取消掉：[root@localhost Desktop]# alias rmalias rm=&#39;rm -i&#39;[root@localhost Desktop]# unalias rm[root@localhost Desktop]# rm out.txt 第3步骤阶段就是由Bash解释器来判断用户输入的是个内部命令还是个外部命令，内部命令是解释器内部的指令，会被直接的执行，而绝大部分的时候都会是外部命令，交由给第4步骤来继续处理，您可以使用“type 命令名称”来手工判断是内部命令还是外部命令，也是很有趣的。 第4步骤阶段是系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫做PATH，可以简单把它理解成是“解释器的小助手”，作用是告诉Bash解释器要执行的命令可能存放到了那里，然后Bash解释器就会乖乖的在这些目录中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，咱们对PATH变量内这些路径的增加和删除操作将会直接影响bash解释器搜索linux命令的位置。[root@localhost Desktop]# echo $PATH/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin[root@localhost Desktop]# echo PATH=$PATH:/root/binPATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/caijy/.local/bin:/home/caijy/bin:/root/bin 这里有比较经典的问题：“为什么不能在$PATH中添加进当前目录(.)?”答案：虽然把$PATH变量添加了当前目录(.)会在一些情况让用户免去输入命令所在路径的麻烦，但如果黑客在比较常用的公共目录/tmp中存放了一个名为”ls”或”cd”的同名木马文件，那么用户就极有可能错误的执行了。作为一名态度谨慎、有经验的运维人员在接手了一台Linux系统后一定会在执行命令前先检查下PATH变量中是否有可疑的目录，另外读者们从PATH变量的例子中是不是也感觉到环境变量特别实用呢~您可以使用env命令来查看到linux系统中所有的环境变量，在此摘录最重要的10个环境变量： 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的SHELL解释器名称。 HISTSIZE 定义了 history 命令输出的记录数 HISTFILESIZE 定义了在文件 ~/.bash_history 中保存命令的记录总数 MAIL 邮件信箱文件保存路径。 LANG 系统语言、语系名称。 RANDOM 生成一个随机数字。 PS1 bash解释器的提示符。 PATH 定义解释器搜索用户执行命令的路径。 EDITOR 用户默认的文本编辑器。 Linux系统为了能够为每个用户提供独立的、合适的工作运行环境，因此在不同的用户身份下提取一个相同的变量也可能会获得不同的值，例如查看下HOME变量在不同用户身份下的值都有那些吧（su是用于切换用户身份的命令）：[root@localhost Desktop]# echo $HOME/root[root@localhost Desktop]# su - caijyLast login: Thu Sep 14 11:01:16 CST 2017 on pts/0[caijy@localhost ~]$ echo $HOME/home/caijy 其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，如果工作需要完全可以自己手工创建的，例如设置一个名称为WORKDIR的变量，方便用户更轻松的进入一个很深层的目录：[caijy@localhost Desktop]$ mkdir -p c/workdir[caijy@localhost Desktop]$ WORKDIR=c/workdir[caijy@localhost Desktop]$ cd $WORKDIR[caijy@localhost workdir]$ pwd/home/caijy/Desktop/c/workdir 但是这样的变量不具有全局性，作用范围也是有限的，默认不能够被其他用户使用的，如果工作需要的话咱们可以使用export命令将其提升为全局变量，这样其他的用户也就可以使用到这个变量了。 转载自：http://www.linuxprobe.com/chapter-03.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程02]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B02%2F</url>
    <content type="text"><![CDATA[新手必须掌握的Linux命令 shell简介通常计算机硬件是由运算器、控制器、存储器、输入/输出设备等等这些物理设备共同组成的，而能够让机箱内各种硬件设备各司其职的东西就叫做系统内核。Linux系统的内核负责驱动硬件、管理活动和分配/管理硬件资源等等任务，如此说来系统内核对计算机正常稳定的运行来讲可真的是太重要了，因此一般不建议直接去编辑内核中的参数，而是让用户通过基于“系统调用接口”开发出的程序/服务来管理计算机，这样一层层环环相扣来满足咱们的日常工作需要.“Shell”——也可称为“壳”，充当的是人与内核（硬件）的翻译官，用户把一些命令“告诉”Shell终端，它就会调用相应的程序服务执行工作啦主流Linux系统选择Bash解释器作为命令行终端主要有以下4项优势: 通过上下方向键来调取过往执行过的Linux命令。 命令或参数仅需输入前几位就可以用tab键补全。 强大的批处理脚本。 实用的环境变量。 man–帮助命令常见执行Linux命令的格式是这样的(中间有空格)： 命令名称 [命令参数] [命令对象] 命令对象一般是指要被处理的文件、目录、用户等资源，而命令参数可以选用长格式（完整的选项名称）也可选用短格式（单个字母的缩写），一般分别用”–”与”-“做前缀。 长格式如:man –help短格式如:man -h 进入Linux，打开terminal,输入：man man,便可看到man命令自身的帮助信息： 进入man命令帮助信息界面后的常用操作按键包括有（与后面章节中学习的vim编辑器非常相像）: 按键 用处 空格键 向下翻一页 Page Down 向下翻一页 Page Up 向上翻一页 HOME 去往首页 END 去往尾页 /关键词 从上至下搜索“关键词” ？关键词 从下至上搜索“关键词” n 定位到下一个关键词 N 定位到上一个关键词 q 退出帮助文档 一般帮助文档都很长，我们应该了解它们的结构来更好得获得帮助 结构名称 代表意义 NAME 命令的名称 SYNOPSIS 参数的大致用法 DESCRIPTION 介绍说明 EXAMPLES 举例说明 OVERVIEW 概述 DEFAULTS 默认的功能 OPTIONS 可用的选项 ENVIRONMENT 环境变量 FILES 用到的文件 SEE ALSO 相关的资料 HISTORY 维护历史 常用系统工作命令echo命令用于在终端显示字符串或输出变量提取后的值，格式为：“echo [字符串 | $变量]”。把指定字符串输出到终端屏幕：使用$变量的方式提取变量值并输出到屏幕： date命令用于显示及设置系统的时间或日期，格式为：”date [选项] [+指定的格式]”。date命令参数常见的格式如下： 参数 作用 %t 跳格（tab键） %H 小时（00-23） %I 小时（00-12） %M 分钟（00-59） %S 秒（00-59） %p 显示本地AM或PM %X 相当于%I:%M:%S %p %Z 显示时区 %A 星期几 (Sunday-Saturday) %a 星期几 (Sun-Sat) %B 完整月份 (January-December) %b 缩写月份 (Jan-Dec) %d 日(01-31) %j 一年中的第几天(001-366) %m 月份(01-12) %Y 完整的年份 按照默认的格式查看当前的系统时间：[caijy@localhost Desktop]$ dateTue Sep 12 20:33:37 CST 2017按照”年-月-日 小时:分钟:秒”的格式查看当前的系统时间：[caijy@localhost Desktop]$ date &quot;+%Y-%m-%d %H:%M:%S&quot;2017-09-12 20:35:30设置当前的系统时间为2017年9月12日21点00分：[caijy@localhost Desktop]$ sudo date -s &quot;20170912 21:00:00&quot;Tue Sep 12 21:00:00 CST 2017再次查看系统时间[caijy@localhost Desktop]$ dateTue Sep 12 21:01:04 CST 2017查看今天是一年中的第几天，其实用这个参数也能够很好的区分备份时间的新旧，即数字越大，越靠近当前时间：[caijy@localhost Desktop]$ date &quot;+%j&quot;255 reboot命令用于重启系统，格式为：”reboot”。重启计算机这种操作会涉及到对硬件资源的管理权限，因此默认只能使用root用户来重启您的电脑：[caijy@localhost Desktop]$ reboot poweroff命令用于关闭系统，格式为：”poweroff”。关机命令也同理，默认只有root管理员用户才可以关闭您的电脑：[caijy@localhost Desktop]$ poweroff wget命令用于在终端中下载网络文件，格式为：“wget [参数] 下载地址”。 参数 说明 -b 后台下载模式 -O 下载到指定mul -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源,包括图片、视频等。 -r 递归下载 ps命令用于查看系统中的进程状态，格式为：“ps [参数]”，常见的ps命令参数有 参数 作用 -a 显示所有的进程（包括其他用户的） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux系统中时刻运行着许许多多的进程，如果能够合理的管理它们，绝对有益于对系统的性能优化，Linux系统中进程最常见的5种不同的状态是运行、中断、不可中断、僵死与停止，它们的含义分别是： R(运行):正在运行或在运行队列中等待。 S(中断):休眠中, 在等待某个条件的形成或接收到信号。 D(不可中断):收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。 Z:(僵死):进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。 T:(停止):进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行。 top命令用于动态的监视进程活动与系统负载等信息，格式为：“top”。这个top命令可真的是太厉害了，它能够动态的查看系统运维状态，完全可以比喻成是“强化版的Windows任务管理器”， top命令前面的五行为系统整体的统计信息： 第1行:系统时间，运行时间，登录终端数，系统负载（分别为1分钟、5分钟、15分钟的平均值，数值越小意味着负载越低）。 第2行:进程总数，运行中的，睡眠中的，停止的，僵死的。 第3行:用户占用资源，系统内核占用资源，改变过优先级的进程，空闲的资源，等待输入输出的时间。此行数据均为CPU数据并以百分比格式显示，例如”99.2 id”意味着有99.2%的CPU处理器资源正在空闲中。 第4行:物理内存总量，使用量，空闲量，作为内核缓存的内存量。 第5行:虚拟内存总量，使用量，空闲量，已被提前加载的内存数据。 pidof命令用于查询某个指定服务进程的PID号码值，格式为：“pidof [参数] [服务名称]”。PID值是区别每个进程的唯一号码，每次在计算机上运行相同的服务程序都很少会获得同样值的PID号码，例如查询下本机sshd服务程序的PID进程号码值：[caijy@localhost Desktop]$ pidof sshd1736 kill命令用于终止某个指定PID号码的服务进程，格式为：“kill [参数] [进程PID号]”。咱们来动手把上面pidof命令查询到的PID号码给终止掉吧，这样操作的效果等同于把sshd服务强制停止。[caijy@localhost Desktop]$ sudo kill 1736killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。(目前尚未安装网卡，找个例子)[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 平时在系统终端中执行一个命令后如果想立即的停止它，您可以同时按下系统组合键“Ctrl+c”，这样命令的进程将会立即被终止，是生产工作中比较常用的命令行快捷键之一。或者有些命令在执行时会不断的在屏幕上输出信息，影响到咱们继续输入命令了，便可以在执行命令时在命令最后面添加上一个“&amp;”符号，这样命令从开始执行就默认被放到系统后台了。 常用系统工作命令为了更好的了解Linux服务器，成为一名合格的运维人员，您必须具备快速查看Linux系统运行状态的能力，因此接下来咱们会逐个来学习下对于网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断命令的使用方法，都是超级实用的Linux命令哦~ ifconfig用于获取网卡配置与网络状态等信息:格式为”ifconfig [网络设备] [参数]”。查看本机当前的网卡配置与网络状态等信息，主要就是看每段开头的网卡名称、inet参数后面的IP地址、ether参数后面的MAC网卡物理地址以及RX、TX的接收与发送数据包的流量大小。 uname命令用于查看系统内核与系统版本等信息，格式为：“uname [-a]”。一般会固定搭配上-a参数来完整查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息:[caijy@localhost Desktop]$ uname -aLinux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux顺便说下，如果您想查看当前系统版本的详细信息需要看redhat-release文件：[caijy@localhost Desktop]$ cat /etc/redhat-releaseRed Hat Enterprise Linux Server release 7.0 (Maipo) uptime命令用于查看系统的负载信息，格式为：“uptime”。这个命令可以为您显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息数据。平均负载值指的是最近1分钟、5分钟、15分钟的系统压力情况（下面加粗的信息部分），负载值越低越好[caijy@localhost Desktop]$ uptime21:14:39 up 31 min, 2 users, load average: 0.20, 0.19, 0.14 free命令用于显示当前系统中内存的使用量信息，格式为：“free [-h]”。为了保证Linux系统不会因硬件故障而突然卡住宕机，那么内存使用量当之无愧是运维人员最应该时刻要关注的数据对象啦，可以使用-h参数来以更人性化的样输出当前内存的实时使用量信息 who命令用于查看当前登入主机的用户终端信息，格式为：”who [参数]”。简单三个字母就可以快捷的显示出所有正在登录着本机的用户名称以及他们正在开启的终端信息： last命令用于查看所有系统的登入记录，格式为：”last [参数]”。使用last命令可以看到本机的登录记录，但由于这些信息都是被以日志文件的形式保存在系统中的数据内容，骇客们很轻易的便可对内容进行篡改，所以千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！ history命令用于显示历史执行过的命令，格式为：“history [-c]”。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录，觉得1000不够用的话还可以修改/etc/profile文件的HISTSIZE变量值，或者使用-c参数来清空里面的历史数据，还可以使用“!编码数字”的方式来重复执行某一次的命令，有很多种有趣的玩法： 历史命令会被保存到用户家目录中的”.bash_history”文件中。Linux系统中以点(.)开头的文件均代表隐藏文件，一般大多会是系统服务文件。[caijy@localhost Desktop]$ cat ~/.bash_history清空该用户在本机中执行的Linux命令历史记录信息：[caijy@localhost Desktop]$ history -c sosreport命令用于收集系统配置并诊断信息后输出结论文档，格式为：“sosreport”。。。有待学习 工作目录切换命令pwd命令用于显示当前所处的工作目录，格式为：“pwd [选项]”。[caijy@localhost Desktop]$ pwd/home/caijy/Desktop cd命令用于切换工作路径，格式为：“cd [目录名称]”。这个命令应该是最最常用的Linux命令之一了，您可以通过cd命令来便捷的切换到不同的工作目录。除了常见的切换目录的方式，还可以使用“cd -”命令来返回到上一次所处的目录或使用“cd ~”命令来切换到当前用户的家目录，亦或使用“cd ~username”则可以切换到其他用户的家目录了~例如使用“cd 路径”的方式切换进/etc目录中：[caijy@localhost Desktop]$ cd /etc同样的道理，再尝试切换进/bin目录中：[caijy@localhost etc]$ cd /bin此时返回到上一次的目录（即/etc目录）：[caijy@localhost bin]$ cd -/etc还可以快速的切换到用户自己的家目录呢：[caijy@localhost etc]$ cd ~[caijy@localhost ~]$ ls命令用于显示目录中的文件信息，格式为：“ls [选项] [文件] ”。当咱们处在不同的工作目录下时，能够看到当前目录下的文件也在发生变化，ls命令的“-a”参数看到全部文件（包括隐藏文件），再结合“-l”参数来查看文件的属性、大小等详细信息。整合之后的命令即可实现查看当前目录中所有文件列表并输出这些文件的属性信息：需要看目录属性信息的话，需要额外添加一个-d参数才可以，例如查看/etc目录的权限与属性信息：[caijy@localhost ~]$ ls -ld /etcdrwxr-xr-x. 132 root root 8192 Sep 12 20:48 /etc 文本文件编辑命令在Linux系统中一切都是文件，而对于服务程序的配置自然也就是在编辑程序的配置文件，如果不能熟练的查阅数据，那以后工作时可就真的要尴尬了。接下来学习几条用于查看文本文件内容的命令吧cat命令用于查看纯文本文件（较短的），格式为：“cat [选项] [文件]”。Linux系统中有需要用于查看文本内容的命令，但其中每个命令又都有自己的特色特点，比如这个cat命令就是用于查看比较精简的文本内容的。这个其实是最好记的命令之一，因为cat在英语中是猫的意思，小猫咪是不是总给您一种娇小、可爱的感觉呢？另外如果您想看文本内容时还顺便显示行号的话，不妨再追加一个“-n”参数试试吧：more命令用于查看纯文本文件（较长的），格式为：“more [选项] 文件”。对于长篇的文本内容，推荐使用more命令来查看文本内容，不仅可以提示您已经阅读了百分之多少，还可以使用空格或回车键向下翻页：head命令用于查看纯文本文档的前N行，格式为：“head [选项] [文件]”。tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为：“tail [选项] [文件]”。当然咱们还会遇到一种更奇葩的情况，比如需要去查看文本内容的最后20行，那么操作方法其实跟head命令是非常相似的，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。而tail命令最强悍的功能是用于持续刷新一个文件的内容，尤其是对于想要实时看到最新日志文件的时候特别有用：tr命令用于替换文本文件中的字符，格式为:“tr [原始字符] [目标字符]”。例如试试把某个文本内容完整替换成大写英文吧：[caijy@localhost Desktop]$ cat 2.txtabcdefghijklmnopqrstuvwxyz[caijy@localhost Desktop]$ cat 2.txt | tr [a-z] [A-Z]ABCDEFGHIJKLMNOPQRSTUVWXYZ wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 例如可以使用“-l”参数来统计行数，而passwd是用于保存系统帐户信息的文件，因此下面的命令就是用于统计当前系统中有多少个用户的作用啦：[caijy@localhost Desktop]$ wc -l /etc/passwd38 /etc/passwd stat命令用于查看文件的具体存储信息和时间等信息，格式“stat 文件名称”。 cut命令用于按“列”来提取文本字符，格式为：“cut [参数] 文本”。如何准确的提取出最想要的数据，这也应该是咱们学习研究的方向之一，按基于“行”的方式来提取是比较简单的，只需要设置好要搜索的关键词即可，但是按列搜索的话不仅要使用“-f”参数来设置需要看的列数，还必须使用“-d”参数来设置间隔符号。因为passwd是用于保存用户信息数据的文件且每一项值都是通过冒号来间隔的，因此可以来尝试下提取出passwd文件中的用户名信息吧，即提取以:（冒号）为间隔符号的第一列内容：[caijy@localhost Desktop]$ head -n 2 /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin[caijy@localhost Desktop]$ cut -d: -f1 /etc/passwdrootbindaemonadmlpsyncshutdownhaltmailoperatorgamesftpnobodydbuspolkitdunboundcolordusbmuxdavahiavahi-autoipdlibstoragemgmtsaslauthqemurpcrpcusernfsnobodyrtkitradvdntpchronyabrtpulsegdmgnome-initial-setuppostfixsshdtcpdumpcaijy diff命令用于比较多个文本文件的差异，格式为：”diff [参数] 文件”。仅仅显示比较后的结果，判断文件是否相同：diff --brief diff_A.txt diff_B.txt使用详细的上下文输出格式来描述文件内容具体的不同：diff -c diff_A.txt diff_B.txt 文件目录管理命令touch命令用于创建空白文件与设置文件的各种时间，格式为：“touch [选项] [文件]”。touch命令能够创建出空白的文本文件，但这实在太简单不需要去讲，例如“touch linuxprobe”这样就可以创建出一个空白的名为linuxprobe的文本文件，而有难度的操作主要是用于设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）。 参数 作用 -a 仅修改访问时间“atime” -m 仅修改更改时间“mtime” -d 同时修改atime与mtime [caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16314 Sep 12 21:42 1.txt[caijy@localhost Desktop]$ echo &quot;hello,linux&quot; &gt;&gt; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Sep 13 19:46 1.txt[caijy@localhost Desktop]$ touch -d &quot;2017-06-06 12:22&quot; 1.txt[caijy@localhost Desktop]$ ls -l 1.txt-rw-rw-r--. 1 caijy caijy 16326 Jun 6 12:22 1.txt mkdir命令用于创建空白的文件夹，格式为：“mkdir [选项] 目录”。在Linux系统中文件夹是最常见的文件类型之一，除了能创建单个目录外，还可以使用“-p”参数来递归创建出具有嵌套叠层关系的文件目录。[caijy@localhost Desktop]$ mkdir linux[caijy@localhost Desktop]$ cd linux[caijy@localhost linux]$ mkdir -p a/b/c/d[caijy@localhost linux]$ cd a[caijy@localhost a]$ cd b[caijy@localhost b]$ cp命令用于复制文件或目录，格式为：“cp [选项] 源文件 目标文件”。在Linux系统中的复制操作具体还分为3种情况，第一种情况是如果目标对象是个目录，则会把源文件复制到该目录中.，第二种情况是如果目标对象也是个普通文件，则会询问是否要覆盖它.最后是第三种的情况了，如果目标文件是不存在的，则会是正常的复制操作啦。 参数 作用 -p 保留原始文件的属性 -d 若对象为”链接文件”，则保留该”链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p,d,r为上述的参数） 首先创建一个名为install.log的普通空白文件，然后把其复制出来一份名为x.log的备份文件：[caijy@localhost Desktop]$ touch install.log[caijy@localhost Desktop]$ cp install.log x.log[caijy@localhost Desktop]$ lsinstall.log x.log mv命令用于移动文件或改名，格式为：“mv [选项] 源文件 [目标路径|目标文件名]”。剪切操作不同于复制操作，因为它会默认把源文件删除掉，操作后就只有剪切后的文件了，并且如果对一个文件在同一个目录中进行剪切操作，其实也是重命名的作用：[caijy@localhost Desktop]$ mv x.log linux.log rm命令用于删除文件或目录，格式为：“rm [选项] 文件”。使用“-i”参数删除文件时向您询问是否要执行删除操作，您可以使用“-f”参数来直接强制删除，另外想要删除一个目录文件夹的话就需要再追加一个“-r”参数才可以，否则是删除不掉的，例如来尝试删除下刚刚那两个文件吧：[caijy@localhost Desktop]$ lsinstall.log linux.log[caijy@localhost Desktop]$ rm -i install.logrm: remove regular empty file ‘install.log’? y[caijy@localhost Desktop]$ rm -rf linux.log[caijy@localhost Desktop]$ ls[caijy@localhost Desktop]$ dd命令用于指定大小的拷贝文件或指定转换文件，格式为：“dd [参数]”。dd命令是个比较重要且具有特色的一个命令，它能够让用户指定数据块的大小和个数来复制一个文件的内容，当然如果您愿意的话还可以在复制过程中转换其中的数据。Linux系统中有一个叫做/dev/zero的设备文件，这个文件不会占用您的系统存储空间，但里面却可以提供无穷无尽的数据，因此用dd命令来生成出来一个指定大小的文件是再好不过的了。 参数 作用 if 输入的文件名称。 of 输出的文件名称。 bs 设置每个“块”的大小。 count 设置要拷贝“块”的个数。 [caijy@localhost Desktop]$ dd if=/dev/zero of=560_file count=1 bs=560M1+0 records in1+0 records out587202560 bytes (587 MB) copied, 2.62394 s, 224 MB/s dd命令也绝对不仅限于复制文件这么简单，如果您想把一个光盘设备制作成iso格式的镜像文件，在Windows系统中一定免不了要用到第三方软件才能做到，但在Linux系统中就可以直接使用dd命令来复制并压制光盘设备变成一个可立即使用的iso镜像哦，例如：[root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso7311360+0 records in7311360+0 records out3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s file命令用于查看文件的类型，格式为：“file 文件名”。如此看来在Linux系统中文本、目录、设备等等这些一切都会可以被统称为文件，而咱们一般又不能单凭后缀就知道具体的文件类型，这时只能用file命令来查看下文件类型啦~[caijy@localhost Desktop]$ touch linux.log[caijy@localhost Desktop]$ file linux.loglinux.log: empty[caijy@localhost Desktop]$ file /dev/sda/dev/sda: block special 打包压缩与搜索命令tar命令用于对文件打包压缩或解压，格式为：“tar [选项] [文件]”。Linux系统中常见的格式比较多，主要使用的是.tar或.tar.gz或.tar.bz2格式，大部分都是由tar命令来完成的，首先“-c”参数是用于创建压缩文件的，“-x”参数是用于解压文件的，因此这两个不能同时放一起使用，其次“-z”参数是指定使用Gzip格式来压缩解压文件，“-j”参数是指定使用bzip2格式来压缩解压文件。解压时候则是根据文件的后缀来决定是何种格式参数，而有些打包操作要数个小时，屏幕没有输出的话您一定会怀疑电脑死机了，也不好判断打包的进度情况，因此非常推荐使用“-v”参数来不断显示压缩或解压的过程给用户，“-C”参数用于指定要解压到的哪个指定的目录，而“-f”参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。我会一般使用“tar -czvf 压缩包名称.tar.gz 要打包的目录”命令来把指定的文件来打包压缩，解压的话则是“tar -xzvf 压缩包名称.tar.gz”命令，接下来使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：[caijy@localhost Desktop]$ tar -czvf etc.tar.gz /etctar: Removing leading `/&#39; from member names/etc//etc/fstabtar: /etc/crypttab: Cannot open: Permission denied/etc/mtab/etc/fonts//etc/fonts/conf.d//etc/fonts/conf.d/65-0-lohit-bengali.conf...... 然后把刚刚打包的压缩包文件指定解压到mydir目录中：[caijy@localhost Desktop]$ tar -xzvf etc.tar.gz -C mydiretc/etc/fstabetc/mtabetc/fonts/etc/fonts/conf.d/etc/fonts/conf.d/65-0-lohit-bengali.conf grep命令用于对文本内容进行关键词的搜索匹配，格式为：“grep [选项] [文件]”。可以把grep命令当作是用途最广泛的文本搜索匹配工具，参数虽然很多但基本是用不到的.这里只说两个最最最常用的参数，只要会使用“-n”参数显示搜索到信息的行号，使用“-v”参数用于反选信息（即没有包含关键词的所有信息行）。Linux系统中的/etc/passwd文件是保存着所有用户信息的文件，而一旦用户的登录终端被设置成“/sbin/nologin”则不再允许登录系统，因此可以通过使用grep命令来匹配出当前系统中所有不允许登录系统的用户信息：[caijy@localhost Desktop]$ grep -n /sbin/nologin /etc/passwd2:bin:x:1:1:bin:/bin:/sbin/nologin3:daemon:x:2:2:daemon:/sbin:/sbin/nologin4:adm:x:3:4:adm:/var/adm:/sbin/nologin5:lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin...... find命令用于在Linux系统中按照指定条件查找文件，格式为：“find [查找路径] 寻找条件 操作”。“Linux系统中的一切都是文件”，在Linux系统中的搜索工作一般都是通过find命令来完成的，它可以根据不同的文件特性来做为匹配项（如文件名、大小、修改时间、权限等信息），一旦匹配到了则会默认为用户显示到屏幕上来，基础的匹配项目请见下表即可。我主要讲解下“–exec”参数重要的作用，这个参数是用于把find命令搜索到的结果交由给后面的命令再进一步做处理，十分类似于后面博文提到的管道符技术。 参数 作用 -name 匹配名称 -perm 匹配权限（mode为完全匹配，-mode为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime 匹配修改内容的时间（-n指n天以内，+n指n天以前） -atime -n +n 匹配访问文件的时间-n指n天以内，+n指n天以前 -ctime -n +n 匹配修改权限的时间-n指n天以内，+n指n天以前 -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件f1新却比f2旧的文件 –type b/d/c/p/l/f 匹配文件类型（块设备、目录、字符设备、管道、链接文件、文件文件） -size 匹配文件的大小（+50k查找超过50k的文件,而-50k则代表查找小于50k的文件） -prune 忽略某个目录 -exec {} \; 后面可接对搜索到结果进一步处理的命令（下面会有演示） Linux系统中的配置文件根据FHS协议会被保存到/etc目录中，如果要想获取到该目录中所有以host开头的文件列表就可以这样做：[caijy@localhost Desktop]$ sudo find /etc -name &quot;host*&quot; -print[sudo] password for caijy:/etc/avahi/hosts/etc/host.conf/etc/hosts 想要在整个系统中搜索所有权限中包括SUID权限的文件，只需使用减号-4000即可：[caijy@localhost Desktop]$ sudo find / -perm -4000 -print/usr/bin/fusermount/usr/bin/su/usr/bin/chage/usr/bin/gpasswd...... 转载自：http://www.linuxprobe.com/chapter-02.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础课程01]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B01%2F</url>
    <content type="text"><![CDATA[经济有限，笔者在虚拟机上安装的“红帽”，具体安装步骤在此不展开论述，不会的同学参考虚拟机/红帽安装及工具下载。 重置root用户密码记得笔者一次面试的时候被问到：如果忘记MySQL root用户的密码怎么办？我一想，这种问题就该直接谷歌，结果被鄙视一脸。后来查了一下，无非是几个命令。在此记录这个比较重要的问题，此处以红帽系统为例（大家先确认自己的Linux系统是不是红帽）： 重启Linux，在引导界面按“e” 在linux16参数这行的后面追加“rd.break”参数并同时一起按下键盘“ctrl“和“x”按键来执行内核参数 过一会儿便进入系统的紧急求援模式。依次输入一下命令（其中第三行命令的“123456”是你新的root用户密码）： mount -o remount,rw /sysroot chroot /sysroot echo “123456” | passwd –stdin root touch /.autorelabel exit reboot然后等待重启即可 RPM红帽软件包这里总结一下常用的软件包命令： 安装软件的命令格式:rpm -ivh filename.rpm 升级软件的命令格式:rpm -Uvh filename.rpm 卸载软件的命令格式:rpm -e filename.rpm 查询软件的描述信息的命令格式:rpm -qpi filename.rpm 列出软件的文件信息的命令格式:rpm -qpl filename.rpm 查询文件属于哪个RPM的命令格式:rpm -qf filename Yum软件仓库Yum软件仓库是为了进一步降低软件安装难度和复杂度而设计的技术，Yum软件仓库可以根据用户的要求分析出所需软件包及其相关依赖关系，然后自动从服务器下载软件包并安装到系统，下面的Yum命令过一下即可。 命令 作用 yum repolist all 列出所有仓库 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 yum remove 软件包名称 移除软件包 yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove 软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 Systemd初始化进程Linux操作系统开机过程首先从BIOS开始，进入“Boot Loader”，加载系统内核，，内核进行初始化，启动初始化进程。初始化进程作为系统第一个进程，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。systemd初始化进程服务采用了并发启动机制，开机速度得到了不小的提升。红帽RHEL7系统启动时要做大量的初始化工作，例如挂在文件系统和交换分区。启动各类进程服务等操作，这些都可以看作一个个的单元（Unit），即用”目标(target)”代替了“运行级别”这个概念，区别如下表所示： Sysvinit运行级别 System目标名称 作用 0 runlevel0.target, poweroff.target 关机 1 runlevel1.target, rescue.target 单用户模式 2 runlevel2.target, multi-user.target 等同于级别3 3 runlevel3.target, multi-user.target 多用户的文本界面 4 runlevel4.target, multi-user.target 等同于级别3 5 runlevel5.target, graphical.target 多用户的图形界面 6 runlevel6.target, reboot.target 重启 emergency emergency.target 紧急Shell 红帽RHEL6系统使用service、chkconfig等命令来管理系统服务，红帽RHEL7系统中管理服务使用的是systemctl命令：systemctl管理服务的启动、重启、停止、重载、查看状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 service foo start systemctl start foo.service 启动服务 service foo restart systemctl restart foo.service 重启服务 service foo stop systemctl stop foo.service 停止服务 service foo reload systemctl reload foo.service 重新加载配置文件（不终止服务） service foo status systemctl status foo.service 查看服务状态 systemctl设置服务的开机启动、不启动、查看各级别下服务启动状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 chkconfig foo on systemctl enable foo.service 开机自动启动 chkconfig foo off systemctl disable foo.service 开机不自动启动 chkconfig foo systemctl is-enabled foo.service 查看特定服务是否为开机自启动 chkconfig –list systemctl list-unit-files –type=service 查看各个级别下服务的启动与禁用情况 转载自：http://www.linuxprobe.com/chapter-01.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Linux Blog]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2F%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。 –《Linux就该这么学》读书笔记]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsakura-hly.github.io%2F2017%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
